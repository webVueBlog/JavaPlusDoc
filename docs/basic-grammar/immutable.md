---
title: 不可变对象
author: 哪吒
date: '2020-01-01'
---

> 点击勘误[issues](https://github.com/webVueBlog/JavaPlusDoc/issues)，哪吒感谢大家的阅读

<img align="right" width="100" src="https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png">

## 不可变对象

一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。它的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改。

为了保护状态的原子性、可见性、有序性，我们程序员可以说是竭尽所能。其中，synchronized（同步）关键字是最简单最入门的一种解决方案。

假如说类是不可变的，那么对象的状态就也是不可变的。这样的话，每次修改对象的状态，就会产生一个新的对象供不同的线程使用，我们程序员就不必再担心并发问题了。

### 常见的不可变类

1）常量池的需要

字符串常量池是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串在常量池中不存在，那么就创建一个；假如已经存，就不会再创建了，而是直接引用已经存在的对象。这样做能够减少 JVM 的内存开销，提高效率。

2）hashCode 需要

因为字符串是不可变的，所以在它创建的时候，其 hashCode 就被缓存了，因此非常适合作为哈希值（比如说作为 HashMap 的键），多次调用只返回同一个值，来提高效率。

3）线程安全

就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而 String 是不可变的，就可以在多个线程之间共享，不需要同步处理。

因此，当我们调用 String 类的任何方法（比如说 trim()、substring()、toLowerCase()）时，总会返回一个新的对象，而不影响之前的值。


## 方法重写 Override 和方法重载 Overload 有什么区别？

01、方法重载

第一，改变参数的数目

第二，通过改变参数类型，也可以达到方法重载的目的。

02、方法重写

重写的方法必须和父类中的方法有着相同的名字；

重写的方法必须和父类中的方法有着相同的参数；

必须是 is-a 的关系（继承关系）。


## 总结

“首先来说一下方法重载时的注意事项，‘两同一不同’。”

	“‘两同’：在同一个类，方法名相同。”

	“‘一不同’：参数不同。”

“再来说一下方法重写时的注意事项，‘两同一小一大’。”

	“‘两同’：方法名相同，参数相同。”

	“‘一小’：子类方法声明的异常类型要比父类小一些或者相等。”

	“‘一大’：子类方法的访问权限应该比父类的更大或者相等。”


## 枚举（enum）


“枚举（enum），是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，继承自 java.lang.Enum。”


	public enum PlayerType {
		TENNIS,
		FOOTBALL,
		BASKETBALL
	}


	public enum PlayerType {
		TENNIS("网球"),
		FOOTBALL("足球"),
		BASKETBALL("篮球");

		private String name;

		PlayerType(String name) {
			this.name = name;
		}
	}





