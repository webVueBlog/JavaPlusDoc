# 第23天-测试和调试

## 学习目标
- 掌握Python单元测试框架
- 学习测试驱动开发(TDD)
- 理解代码覆盖率和测试策略
- 掌握调试技巧和工具
- 学习性能分析和优化

## 1. 单元测试基础

### 1.1 unittest模块

```python
import unittest
import sys
import os

def unittest_basics_demo():
    """unittest基础演示"""
    print("=== unittest基础演示 ===")
    
    # 1. 基础测试类
    print("\n1. 基础测试类:")
    
    basic_unittest_code = '''
# unittest基础使用
import unittest

# 被测试的函数
def add(a, b):
    """加法函数"""
    return a + b

def divide(a, b):
    """除法函数"""
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b

def is_even(n):
    """判断是否为偶数"""
    return n % 2 == 0

class TestMathFunctions(unittest.TestCase):
    """数学函数测试类"""
    
    def setUp(self):
        """每个测试方法执行前调用"""
        print("设置测试环境")
        self.test_data = [1, 2, 3, 4, 5]
    
    def tearDown(self):
        """每个测试方法执行后调用"""
        print("清理测试环境")
        self.test_data = None
    
    def test_add_positive_numbers(self):
        """测试正数加法"""
        result = add(2, 3)
        self.assertEqual(result, 5)
        self.assertIsInstance(result, int)
    
    def test_add_negative_numbers(self):
        """测试负数加法"""
        result = add(-2, -3)
        self.assertEqual(result, -5)
    
    def test_add_zero(self):
        """测试零的加法"""
        self.assertEqual(add(5, 0), 5)
        self.assertEqual(add(0, 5), 5)
        self.assertEqual(add(0, 0), 0)
    
    def test_divide_normal(self):
        """测试正常除法"""
        result = divide(10, 2)
        self.assertEqual(result, 5.0)
        self.assertAlmostEqual(divide(1, 3), 0.333333, places=5)
    
    def test_divide_by_zero(self):
        """测试除零异常"""
        with self.assertRaises(ValueError) as context:
            divide(10, 0)
        
        self.assertIn("除数不能为零", str(context.exception))
    
    def test_is_even(self):
        """测试偶数判断"""
        # 测试偶数
        self.assertTrue(is_even(2))
        self.assertTrue(is_even(0))
        self.assertTrue(is_even(-4))
        
        # 测试奇数
        self.assertFalse(is_even(1))
        self.assertFalse(is_even(3))
        self.assertFalse(is_even(-3))
    
    def test_with_test_data(self):
        """使用测试数据"""
        self.assertIsNotNone(self.test_data)
        self.assertEqual(len(self.test_data), 5)
        self.assertIn(3, self.test_data)

# 运行测试
if __name__ == '__main__':
    # 创建测试套件
    suite = unittest.TestLoader().loadTestsFromTestCase(TestMathFunctions)
    
    # 运行测试
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # 显示结果
    print(f"\n测试结果:")
    print(f"  运行测试: {result.testsRun}")
    print(f"  失败: {len(result.failures)}")
    print(f"  错误: {len(result.errors)}")
    print(f"  成功率: {(result.testsRun - len(result.failures) - len(result.errors)) / result.testsRun * 100:.1f}%")
'''
    
    print("   基础unittest代码:")
    print(basic_unittest_code)
    
    # 2. 断言方法详解
    print("\n2. 断言方法详解:")
    
    assertion_methods = {
        "相等性断言": [
            "assertEqual(a, b) - 断言a等于b",
            "assertNotEqual(a, b) - 断言a不等于b",
            "assertAlmostEqual(a, b, places=7) - 断言a约等于b",
            "assertNotAlmostEqual(a, b, places=7) - 断言a不约等于b"
        ],
        "真值断言": [
            "assertTrue(x) - 断言x为True",
            "assertFalse(x) - 断言x为False",
            "assertIsNone(x) - 断言x为None",
            "assertIsNotNone(x) - 断言x不为None"
        ],
        "类型断言": [
            "assertIsInstance(a, b) - 断言a是b类型的实例",
            "assertNotIsInstance(a, b) - 断言a不是b类型的实例",
            "assertIs(a, b) - 断言a是b（同一对象）",
            "assertIsNot(a, b) - 断言a不是b（不同对象）"
        ],
        "容器断言": [
            "assertIn(a, b) - 断言a在b中",
            "assertNotIn(a, b) - 断言a不在b中",
            "assertCountEqual(a, b) - 断言a和b包含相同元素（忽略顺序）",
            "assertListEqual(a, b) - 断言列表a等于列表b"
        ],
        "异常断言": [
            "assertRaises(exc, fun, *args, **kwds) - 断言调用fun会抛出exc异常",
            "assertRaisesRegex(exc, r, fun, *args, **kwds) - 断言异常消息匹配正则表达式",
            "assertWarns(warn, fun, *args, **kwds) - 断言调用fun会产生warn警告"
        ]
    }
    
    for category, methods in assertion_methods.items():
        print(f"\n   {category}:")
        for method in methods:
            print(f"     • {method}")
    
    # 3. 实际应用演示
    print("\n3. 实际应用演示:")
    
    # 被测试的简单函数
    def demo_add(a, b):
        return a + b
    
    def demo_divide(a, b):
        if b == 0:
            raise ValueError("除数不能为零")
        return a / b
    
    # 创建简单测试
    class DemoTestCase(unittest.TestCase):
        def test_add(self):
            self.assertEqual(demo_add(2, 3), 5)
        
        def test_divide(self):
            self.assertEqual(demo_divide(10, 2), 5.0)
        
        def test_divide_by_zero(self):
            with self.assertRaises(ValueError):
                demo_divide(10, 0)
    
    # 运行演示测试
    suite = unittest.TestLoader().loadTestsFromTestCase(DemoTestCase)
    runner = unittest.TextTestRunner(verbosity=0, stream=open(os.devnull, 'w'))
    result = runner.run(suite)
    
    print(f"   演示测试结果: {result.testsRun} 个测试，{len(result.failures)} 个失败，{len(result.errors)} 个错误")
    
    print("\n   ✓ unittest基础演示完成")

# 运行unittest基础演示
unittest_basics_demo()
```

### 1.2 测试组织和运行

```python
import unittest
from unittest import mock
import tempfile
import shutil

def test_organization_demo():
    """测试组织和运行演示"""
    print("=== 测试组织和运行演示 ===")
    
    # 1. 测试套件组织
    print("\n1. 测试套件组织:")
    
    test_suite_code = '''
# 测试套件组织
import unittest

# 示例被测试类
class Calculator:
    """计算器类"""
    
    def __init__(self):
        self.history = []
    
    def add(self, a, b):
        result = a + b
        self.history.append(f"{a} + {b} = {result}")
        return result
    
    def subtract(self, a, b):
        result = a - b
        self.history.append(f"{a} - {b} = {result}")
        return result
    
    def multiply(self, a, b):
        result = a * b
        self.history.append(f"{a} * {b} = {result}")
        return result
    
    def divide(self, a, b):
        if b == 0:
            raise ValueError("除数不能为零")
        result = a / b
        self.history.append(f"{a} / {b} = {result}")
        return result
    
    def clear_history(self):
        self.history.clear()
    
    def get_history(self):
        return self.history.copy()

# 基础运算测试
class TestBasicOperations(unittest.TestCase):
    """基础运算测试"""
    
    def setUp(self):
        self.calc = Calculator()
    
    def test_addition(self):
        """测试加法"""
        self.assertEqual(self.calc.add(2, 3), 5)
        self.assertEqual(self.calc.add(-1, 1), 0)
        self.assertEqual(self.calc.add(0, 0), 0)
    
    def test_subtraction(self):
        """测试减法"""
        self.assertEqual(self.calc.subtract(5, 3), 2)
        self.assertEqual(self.calc.subtract(0, 5), -5)
        self.assertEqual(self.calc.subtract(-2, -3), 1)
    
    def test_multiplication(self):
        """测试乘法"""
        self.assertEqual(self.calc.multiply(3, 4), 12)
        self.assertEqual(self.calc.multiply(-2, 3), -6)
        self.assertEqual(self.calc.multiply(0, 100), 0)
    
    def test_division(self):
        """测试除法"""
        self.assertEqual(self.calc.divide(10, 2), 5.0)
        self.assertAlmostEqual(self.calc.divide(1, 3), 0.333333, places=5)
    
    def test_division_by_zero(self):
        """测试除零异常"""
        with self.assertRaises(ValueError):
            self.calc.divide(10, 0)

# 历史记录测试
class TestHistory(unittest.TestCase):
    """历史记录测试"""
    
    def setUp(self):
        self.calc = Calculator()
    
    def test_history_recording(self):
        """测试历史记录"""
        self.calc.add(2, 3)
        self.calc.multiply(4, 5)
        
        history = self.calc.get_history()
        self.assertEqual(len(history), 2)
        self.assertIn("2 + 3 = 5", history)
        self.assertIn("4 * 5 = 20", history)
    
    def test_clear_history(self):
        """测试清除历史"""
        self.calc.add(1, 1)
        self.calc.clear_history()
        
        history = self.calc.get_history()
        self.assertEqual(len(history), 0)
    
    def test_history_independence(self):
        """测试历史记录独立性"""
        history1 = self.calc.get_history()
        history1.append("fake entry")
        
        history2 = self.calc.get_history()
        self.assertNotIn("fake entry", history2)

# 边界条件测试
class TestEdgeCases(unittest.TestCase):
    """边界条件测试"""
    
    def setUp(self):
        self.calc = Calculator()
    
    def test_large_numbers(self):
        """测试大数运算"""
        large_num = 10**10
        result = self.calc.add(large_num, large_num)
        self.assertEqual(result, 2 * large_num)
    
    def test_float_precision(self):
        """测试浮点精度"""
        result = self.calc.add(0.1, 0.2)
        self.assertAlmostEqual(result, 0.3, places=10)
    
    def test_negative_numbers(self):
        """测试负数运算"""
        self.assertEqual(self.calc.multiply(-3, -4), 12)
        self.assertEqual(self.calc.divide(-10, -2), 5.0)

# 创建测试套件
def create_test_suite():
    """创建测试套件"""
    suite = unittest.TestSuite()
    
    # 添加测试类
    suite.addTest(unittest.makeSuite(TestBasicOperations))
    suite.addTest(unittest.makeSuite(TestHistory))
    suite.addTest(unittest.makeSuite(TestEdgeCases))
    
    return suite

# 自定义测试套件
def create_custom_suite():
    """创建自定义测试套件"""
    suite = unittest.TestSuite()
    
    # 只添加特定测试
    suite.addTest(TestBasicOperations('test_addition'))
    suite.addTest(TestBasicOperations('test_multiplication'))
    suite.addTest(TestHistory('test_history_recording'))
    
    return suite

# 运行测试套件
def run_test_suite():
    """运行测试套件"""
    print("=== 运行完整测试套件 ===")
    
    # 运行完整套件
    full_suite = create_test_suite()
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(full_suite)
    
    print(f"\n完整测试结果:")
    print(f"  运行: {result.testsRun} 个测试")
    print(f"  失败: {len(result.failures)} 个")
    print(f"  错误: {len(result.errors)} 个")
    
    # 运行自定义套件
    print("\n=== 运行自定义测试套件 ===")
    custom_suite = create_custom_suite()
    result2 = runner.run(custom_suite)
    
    print(f"\n自定义测试结果:")
    print(f"  运行: {result2.testsRun} 个测试")
    print(f"  失败: {len(result2.failures)} 个")
    print(f"  错误: {len(result2.errors)} 个")

# 运行测试套件演示
# run_test_suite()
'''
    
    print("   测试套件组织代码:")
    print(test_suite_code)
    
    # 2. 测试发现和运行
    print("\n2. 测试发现和运行:")
    
    test_discovery_info = {
        "命令行运行": [
            "python -m unittest test_module.TestClass.test_method",
            "python -m unittest test_module.TestClass",
            "python -m unittest test_module",
            "python -m unittest discover -s tests -p 'test_*.py'"
        ],
        "程序化运行": [
            "unittest.main() - 运行当前模块的所有测试",
            "unittest.TextTestRunner().run(suite) - 运行指定套件",
            "unittest.TestLoader().loadTestsFromTestCase(TestClass) - 加载测试类",
            "unittest.TestLoader().discover(start_dir, pattern) - 自动发现测试"
        ],
        "测试选项": [
            "-v, --verbose - 详细输出",
            "-q, --quiet - 安静模式",
            "-f, --failfast - 遇到失败立即停止",
            "-b, --buffer - 缓冲stdout和stderr"
        ]
    }
    
    for category, items in test_discovery_info.items():
        print(f"\n   {category}:")
        for item in items:
            print(f"     • {item}")
    
    # 3. 实际应用演示
    print("\n3. 实际应用演示:")
    
    # 简单的被测试类
    class DemoCalculator:
        def add(self, a, b):
            return a + b
        
        def divide(self, a, b):
            if b == 0:
                raise ValueError("除数不能为零")
            return a / b
    
    # 测试类
    class TestDemoCalculator(unittest.TestCase):
        def setUp(self):
            self.calc = DemoCalculator()
        
        def test_add(self):
            self.assertEqual(self.calc.add(2, 3), 5)
        
        def test_divide(self):
            self.assertEqual(self.calc.divide(10, 2), 5.0)
        
        def test_divide_by_zero(self):
            with self.assertRaises(ValueError):
                self.calc.divide(10, 0)
    
    # 创建并运行测试套件
    suite = unittest.TestLoader().loadTestsFromTestCase(TestDemoCalculator)
    runner = unittest.TextTestRunner(verbosity=0, stream=open(os.devnull, 'w'))
    result = runner.run(suite)
    
    print(f"   演示测试运行结果:")
    print(f"     运行测试: {result.testsRun} 个")
    print(f"     成功: {result.testsRun - len(result.failures) - len(result.errors)} 个")
    print(f"     失败: {len(result.failures)} 个")
    print(f"     错误: {len(result.errors)} 个")
    
    print("\n   ✓ 测试组织和运行演示完成")

# 运行测试组织演示
test_organization_demo()
```

## 2. 高级测试技术

### 2.1 Mock和Patch

```python
from unittest import mock
import requests
import json
from datetime import datetime

def mock_and_patch_demo():
    """Mock和Patch演示"""
    print("=== Mock和Patch演示 ===")
    
    # 1. Mock基础
    print("\n1. Mock基础:")
    
    mock_basics_code = '''
# Mock基础使用
from unittest import mock
import requests
import json
from datetime import datetime

# 被测试的类
class WeatherService:
    """天气服务类"""
    
    def __init__(self, api_key):
        self.api_key = api_key
        self.base_url = "https://api.weather.com"
    
    def get_weather(self, city):
        """获取天气信息"""
        url = f"{self.base_url}/weather"
        params = {
            "key": self.api_key,
            "city": city,
            "format": "json"
        }
        
        try:
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            return {
                "city": city,
                "temperature": data.get("temperature"),
                "humidity": data.get("humidity"),
                "description": data.get("description"),
                "timestamp": datetime.now().isoformat()
            }
        
        except requests.RequestException as e:
            raise Exception(f"获取天气信息失败: {e}")
    
    def get_forecast(self, city, days=5):
        """获取天气预报"""
        url = f"{self.base_url}/forecast"
        params = {
            "key": self.api_key,
            "city": city,
            "days": days
        }
        
        response = requests.get(url, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            return None

class DatabaseManager:
    """数据库管理器"""
    
    def __init__(self, connection_string):
        self.connection_string = connection_string
        self.connected = False
    
    def connect(self):
        """连接数据库"""
        # 模拟数据库连接
        print(f"连接到数据库: {self.connection_string}")
        self.connected = True
        return True
    
    def execute_query(self, query, params=None):
        """执行查询"""
        if not self.connected:
            raise Exception("数据库未连接")
        
        # 模拟查询执行
        print(f"执行查询: {query}")
        if params:
            print(f"参数: {params}")
        
        # 返回模拟结果
        return [{"id": 1, "name": "测试数据"}]
    
    def close(self):
        """关闭连接"""
        self.connected = False
        print("数据库连接已关闭")

# Mock测试示例
class TestWeatherService(unittest.TestCase):
    """天气服务测试"""
    
    def setUp(self):
        self.weather_service = WeatherService("test_api_key")
    
    @mock.patch('requests.get')
    def test_get_weather_success(self, mock_get):
        """测试成功获取天气"""
        # 设置mock响应
        mock_response = mock.Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "temperature": 25,
            "humidity": 60,
            "description": "晴天"
        }
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
        
        # 执行测试
        result = self.weather_service.get_weather("北京")
        
        # 验证结果
        self.assertEqual(result["city"], "北京")
        self.assertEqual(result["temperature"], 25)
        self.assertEqual(result["humidity"], 60)
        self.assertEqual(result["description"], "晴天")
        self.assertIn("timestamp", result)
        
        # 验证API调用
        mock_get.assert_called_once()
        call_args = mock_get.call_args
        self.assertIn("北京", str(call_args))
    
    @mock.patch('requests.get')
    def test_get_weather_api_error(self, mock_get):
        """测试API错误"""
        # 设置mock抛出异常
        mock_get.side_effect = requests.RequestException("网络错误")
        
        # 验证异常
        with self.assertRaises(Exception) as context:
            self.weather_service.get_weather("上海")
        
        self.assertIn("获取天气信息失败", str(context.exception))
    
    @mock.patch('requests.get')
    def test_get_forecast(self, mock_get):
        """测试获取预报"""
        # 设置mock响应
        mock_response = mock.Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "forecast": [
                {"date": "2024-01-01", "temp": 20},
                {"date": "2024-01-02", "temp": 22}
            ]
        }
        mock_get.return_value = mock_response
        
        # 执行测试
        result = self.weather_service.get_forecast("广州", 2)
        
        # 验证结果
        self.assertIsNotNone(result)
        self.assertIn("forecast", result)
        self.assertEqual(len(result["forecast"]), 2)

class TestDatabaseManager(unittest.TestCase):
    """数据库管理器测试"""
    
    def setUp(self):
        self.db = DatabaseManager("test://localhost/testdb")
    
    def test_connect(self):
        """测试连接"""
        result = self.db.connect()
        self.assertTrue(result)
        self.assertTrue(self.db.connected)
    
    @mock.patch.object(DatabaseManager, 'connect')
    def test_execute_query_without_connection(self, mock_connect):
        """测试未连接时执行查询"""
        # 确保未连接
        self.db.connected = False
        
        # 验证异常
        with self.assertRaises(Exception) as context:
            self.db.execute_query("SELECT * FROM users")
        
        self.assertIn("数据库未连接", str(context.exception))
    
    def test_execute_query_with_connection(self):
        """测试连接后执行查询"""
        # 先连接
        self.db.connect()
        
        # 执行查询
        result = self.db.execute_query("SELECT * FROM users")
        
        # 验证结果
        self.assertIsInstance(result, list)
        self.assertEqual(len(result), 1)
        self.assertEqual(result[0]["id"], 1)

# 运行Mock测试
def run_mock_tests():
    """运行Mock测试"""
    print("=== 运行Mock测试 ===")
    
    # 创建测试套件
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(TestWeatherService))
    suite.addTest(unittest.makeSuite(TestDatabaseManager))
    
    # 运行测试
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    print(f"\nMock测试结果:")
    print(f"  运行: {result.testsRun} 个测试")
    print(f"  失败: {len(result.failures)} 个")
    print(f"  错误: {len(result.errors)} 个")

# 运行Mock测试演示
# run_mock_tests()
'''
    
    print("   Mock基础代码:")
    print(mock_basics_code)
    
    # 2. Patch装饰器和上下文管理器
    print("\n2. Patch装饰器和上下文管理器:")
    
    patch_examples_code = '''
# Patch使用示例
from unittest import mock
import os
import time
from datetime import datetime

# 被测试的函数
def get_current_time():
    """获取当前时间"""
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def read_config_file(filename):
    """读取配置文件"""
    if not os.path.exists(filename):
        raise FileNotFoundError(f"配置文件不存在: {filename}")
    
    with open(filename, 'r') as f:
        content = f.read()
    
    return content.strip()

def process_data_with_delay(data, delay=1):
    """处理数据（带延迟）"""
    time.sleep(delay)
    return [item.upper() for item in data]

class FileProcessor:
    """文件处理器"""
    
    def __init__(self, base_path):
        self.base_path = base_path
    
    def get_file_size(self, filename):
        """获取文件大小"""
        full_path = os.path.join(self.base_path, filename)
        return os.path.getsize(full_path)
    
    def list_files(self):
        """列出文件"""
        return os.listdir(self.base_path)
    
    def create_backup(self, filename):
        """创建备份"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"{filename}.backup_{timestamp}"
        
        # 模拟备份过程
        return backup_name

# Patch测试示例
class TestPatchExamples(unittest.TestCase):
    """Patch示例测试"""
    
    # 1. 使用装饰器patch
    @mock.patch('datetime.datetime')
    def test_get_current_time_with_decorator(self, mock_datetime):
        """使用装饰器测试时间函数"""
        # 设置mock返回值
        mock_datetime.now.return_value.strftime.return_value = "2024-01-01 12:00:00"
        
        # 执行测试
        result = get_current_time()
        
        # 验证结果
        self.assertEqual(result, "2024-01-01 12:00:00")
        mock_datetime.now.assert_called_once()
    
    # 2. 使用上下文管理器patch
    def test_read_config_file_with_context_manager(self):
        """使用上下文管理器测试文件读取"""
        # 模拟文件存在和内容
        with mock.patch('os.path.exists', return_value=True):
            with mock.patch('builtins.open', mock.mock_open(read_data="test config")):
                result = read_config_file("config.txt")
                self.assertEqual(result, "test config")
    
    # 3. 测试文件不存在的情况
    @mock.patch('os.path.exists', return_value=False)
    def test_read_config_file_not_exists(self, mock_exists):
        """测试文件不存在"""
        with self.assertRaises(FileNotFoundError):
            read_config_file("nonexistent.txt")
        
        mock_exists.assert_called_once_with("nonexistent.txt")
    
    # 4. 使用side_effect
    @mock.patch('time.sleep')
    def test_process_data_with_delay(self, mock_sleep):
        """测试带延迟的数据处理"""
        # 跳过实际的sleep
        mock_sleep.return_value = None
        
        # 执行测试
        data = ["hello", "world"]
        result = process_data_with_delay(data, delay=2)
        
        # 验证结果
        self.assertEqual(result, ["HELLO", "WORLD"])
        mock_sleep.assert_called_once_with(2)
    
    # 5. 测试类方法
    def test_file_processor(self):
        """测试文件处理器"""
        processor = FileProcessor("/test/path")
        
        # 使用patch.object
        with mock.patch.object(os.path, 'getsize', return_value=1024):
            size = processor.get_file_size("test.txt")
            self.assertEqual(size, 1024)
        
        # 使用patch
        with mock.patch('os.listdir', return_value=["file1.txt", "file2.txt"]):
            files = processor.list_files()
            self.assertEqual(len(files), 2)
            self.assertIn("file1.txt", files)
    
    # 6. 多个patch
    @mock.patch('datetime.datetime')
    @mock.patch('os.path.exists')
    def test_multiple_patches(self, mock_exists, mock_datetime):
        """测试多个patch"""
        # 设置mock
        mock_exists.return_value = True
        mock_datetime.now.return_value.strftime.return_value = "20240101_120000"
        
        # 执行测试
        processor = FileProcessor("/test")
        backup_name = processor.create_backup("test.txt")
        
        # 验证结果
        self.assertEqual(backup_name, "test.txt.backup_20240101_120000")
    
    # 7. 使用spec参数
    def test_with_spec(self):
        """使用spec参数的mock"""
        # 创建带spec的mock
        mock_file = mock.Mock(spec=open)
        mock_file.read.return_value = "mocked content"
        
        # 验证spec限制
        self.assertTrue(hasattr(mock_file, 'read'))
        self.assertTrue(hasattr(mock_file, 'write'))
        
        # 尝试访问不存在的属性会报错
        with self.assertRaises(AttributeError):
            _ = mock_file.nonexistent_method

# 运行Patch测试
def run_patch_tests():
    """运行Patch测试"""
    print("=== 运行Patch测试 ===")
    
    suite = unittest.TestLoader().loadTestsFromTestCase(TestPatchExamples)
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    print(f"\nPatch测试结果:")
    print(f"  运行: {result.testsRun} 个测试")
    print(f"  失败: {len(result.failures)} 个")
    print(f"  错误: {len(result.errors)} 个")

# 运行Patch测试演示
# run_patch_tests()
'''
    
    print("   Patch示例代码:")
    print(patch_examples_code)
    
    # 3. 实际应用演示
    print("\n3. 实际应用演示:")
    
    # 简单的被测试类
    class DemoService:
        def get_data(self):
            # 模拟外部API调用
            import requests
            response = requests.get("https://api.example.com/data")
            return response.json()
        
        def get_time(self):
            return datetime.now().strftime("%Y-%m-%d")
    
    # 测试类
    class TestDemoService(unittest.TestCase):
        def setUp(self):
            self.service = DemoService()
        
        @mock.patch('requests.get')
        def test_get_data(self, mock_get):
            # 设置mock响应
            mock_response = mock.Mock()
            mock_response.json.return_value = {"result": "success"}
            mock_get.return_value = mock_response
            
            # 执行测试
            result = self.service.get_data()
            
            # 验证结果
            self.assertEqual(result["result"], "success")
            mock_get.assert_called_once_with("https://api.example.com/data")
        
        @mock.patch('datetime.datetime')
        def test_get_time(self, mock_datetime):
            # 设置mock时间
            mock_datetime.now.return_value.strftime.return_value = "2024-01-01"
            
            # 执行测试
            result = self.service.get_time()
            
            # 验证结果
            self.assertEqual(result, "2024-01-01")
    
    # 运行演示测试
    suite = unittest.TestLoader().loadTestsFromTestCase(TestDemoService)
    runner = unittest.TextTestRunner(verbosity=0, stream=open(os.devnull, 'w'))
    result = runner.run(suite)
    
    print(f"   Mock演示测试结果:")
    print(f"     运行测试: {result.testsRun} 个")
    print(f"     成功: {result.testsRun - len(result.failures) - len(result.errors)} 个")
    print(f"     失败: {len(result.failures)} 个")
    print(f"     错误: {len(result.errors)} 个")
    
    print("\n   ✓ Mock和Patch演示完成")

# 运行Mock和Patch演示
mock_and_patch_demo()
```

### 2.2 参数化测试

```python
import unittest
from unittest import TestCase
import itertools

def parameterized_tests_demo():
    """参数化测试演示"""
    print("=== 参数化测试演示 ===")
    
    # 1. 手动参数化测试
    print("\n1. 手动参数化测试:")
    
    manual_parameterized_code = '''
# 手动参数化测试
import unittest
from unittest import TestCase

# 被测试的函数
def is_prime(n):
    """判断是否为质数"""
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            return False
    return True

def factorial(n):
    """计算阶乘"""
    if n < 0:
        raise ValueError("负数没有阶乘")
    if n == 0 or n == 1:
        return 1
    
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def fibonacci(n):
    """计算斐波那契数列第n项"""
    if n < 0:
        raise ValueError("n必须为非负整数")
    if n <= 1:
        return n
    
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

# 手动参数化测试类
class TestMathFunctions(TestCase):
    """数学函数测试"""
    
    def test_is_prime_manual_cases(self):
        """手动测试质数判断"""
        # 测试用例：(输入, 期望输出)
        test_cases = [
            (2, True),
            (3, True),
            (4, False),
            (5, True),
            (6, False),
            (7, True),
            (8, False),
            (9, False),
            (10, False),
            (11, True),
            (17, True),
            (25, False),
            (29, True)
        ]
        
        for number, expected in test_cases:
            with self.subTest(number=number):
                result = is_prime(number)
                self.assertEqual(result, expected, 
                               f"is_prime({number}) 应该返回 {expected}，但返回了 {result}")
    
    def test_factorial_manual_cases(self):
        """手动测试阶乘计算"""
        test_cases = [
            (0, 1),
            (1, 1),
            (2, 2),
            (3, 6),
            (4, 24),
            (5, 120),
            (6, 720)
        ]
        
        for n, expected in test_cases:
            with self.subTest(n=n):
                result = factorial(n)
                self.assertEqual(result, expected,
                               f"factorial({n}) 应该返回 {expected}，但返回了 {result}")
    
    def test_factorial_negative_input(self):
        """测试阶乘负数输入"""
        negative_numbers = [-1, -5, -10]
        
        for n in negative_numbers:
            with self.subTest(n=n):
                with self.assertRaises(ValueError):
                    factorial(n)
    
    def test_fibonacci_manual_cases(self):
        """手动测试斐波那契数列"""
        test_cases = [
            (0, 0),
            (1, 1),
            (2, 1),
            (3, 2),
            (4, 3),
            (5, 5),
            (6, 8),
            (7, 13),
            (8, 21),
            (9, 34),
            (10, 55)
        ]
        
        for n, expected in test_cases:
            with self.subTest(n=n):
                result = fibonacci(n)
                self.assertEqual(result, expected,
                               f"fibonacci({n}) 应该返回 {expected}，但返回了 {result}")

# 使用生成器的参数化测试
class TestWithGenerators(TestCase):
    """使用生成器的参数化测试"""
    
    def _generate_prime_test_cases(self):
        """生成质数测试用例"""
        # 已知的质数和合数
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
        composites = [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30]
        
        for prime in primes:
            yield prime, True
        
        for composite in composites:
            yield composite, False
    
    def test_is_prime_with_generator(self):
        """使用生成器测试质数判断"""
        for number, expected in self._generate_prime_test_cases():
            with self.subTest(number=number):
                result = is_prime(number)
                self.assertEqual(result, expected)
    
    def _generate_edge_cases(self):
        """生成边界测试用例"""
        # 边界情况
        yield 0, False  # 0不是质数
        yield 1, False  # 1不是质数
        yield -1, False # 负数不是质数
        yield -5, False # 负数不是质数
    
    def test_is_prime_edge_cases(self):
        """测试边界情况"""
        for number, expected in self._generate_edge_cases():
            with self.subTest(number=number):
                result = is_prime(number)
                self.assertEqual(result, expected)

# 动态生成测试方法
def create_parameterized_test_class():
    """动态创建参数化测试类"""
    
    class DynamicTestClass(TestCase):
        pass
    
    # 测试数据
    test_data = [
        ("test_small_primes", [(2, True), (3, True), (5, True), (7, True)]),
        ("test_small_composites", [(4, False), (6, False), (8, False), (9, False)]),
        ("test_larger_primes", [(11, True), (13, True), (17, True), (19, True)])
    ]
    
    # 动态添加测试方法
    for test_name, cases in test_data:
        def make_test_method(test_cases):
            def test_method(self):
                for number, expected in test_cases:
                    with self.subTest(number=number):
                        result = is_prime(number)
                        self.assertEqual(result, expected)
            return test_method
        
        # 添加到类中
        setattr(DynamicTestClass, test_name, make_test_method(cases))
    
    return DynamicTestClass

# 运行手动参数化测试
def run_manual_parameterized_tests():
    """运行手动参数化测试"""
    print("=== 运行手动参数化测试 ===")
    
    # 运行基础测试
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(TestMathFunctions))
    suite.addTest(unittest.makeSuite(TestWithGenerators))
    
    # 添加动态生成的测试类
    DynamicTestClass = create_parameterized_test_class()
    suite.addTest(unittest.makeSuite(DynamicTestClass))
    
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    print(f"\n手动参数化测试结果:")
    print(f"  运行: {result.testsRun} 个测试")
    print(f"  失败: {len(result.failures)} 个")
    print(f"  错误: {len(result.errors)} 个")

# 运行手动参数化测试演示
# run_manual_parameterized_tests()
'''
    
    print("   手动参数化测试代码:")
    print(manual_parameterized_code)
    
    # 2. 使用第三方库的参数化测试
    print("\n2. 使用第三方库的参数化测试:")
    
    third_party_parameterized_code = '''
# 使用parameterized库的参数化测试
# 需要安装: pip install parameterized

try:
    from parameterized import parameterized
    PARAMETERIZED_AVAILABLE = True
except ImportError:
    PARAMETERIZED_AVAILABLE = False
    print("parameterized库未安装，跳过相关演示")

if PARAMETERIZED_AVAILABLE:
    class TestWithParameterized(TestCase):
        """使用parameterized库的测试"""
        
        @parameterized.expand([
            (2, True),
            (3, True),
            (4, False),
            (5, True),
            (6, False),
            (7, True),
            (8, False),
            (9, False),
            (10, False),
            (11, True)
        ])
        def test_is_prime_parameterized(self, number, expected):
            """参数化测试质数判断"""
            result = is_prime(number)
            self.assertEqual(result, expected)
        
        @parameterized.expand([
            (0, 1),
            (1, 1),
            (2, 2),
            (3, 6),
            (4, 24),
            (5, 120)
        ])
        def test_factorial_parameterized(self, n, expected):
            """参数化测试阶乘"""
            result = factorial(n)
            self.assertEqual(result, expected)
        
        @parameterized.expand([
            (-1,),
            (-5,),
            (-10,)
        ])
        def test_factorial_negative_parameterized(self, n):
            """参数化测试阶乘负数输入"""
            with self.assertRaises(ValueError):
                factorial(n)
        
        @parameterized.expand([
            ("empty_string", "", 0),
            ("single_char", "a", 1),
            ("hello", "hello", 5),
            ("spaces", "hello world", 11)
        ])
        def test_string_length(self, name, string, expected_length):
            """参数化测试字符串长度"""
            self.assertEqual(len(string), expected_length)

# 使用pytest风格的参数化（如果可用）
try:
    import pytest
    PYTEST_AVAILABLE = True
except ImportError:
    PYTEST_AVAILABLE = False

if PYTEST_AVAILABLE:
    # pytest参数化示例（在pytest环境中运行）
    class TestPytestStyle:
        """pytest风格的参数化测试"""
        
        @pytest.mark.parametrize("number,expected", [
            (2, True),
            (3, True),
            (4, False),
            (5, True),
            (6, False)
        ])
        def test_is_prime_pytest(self, number, expected):
            """pytest参数化测试"""
            assert is_prime(number) == expected
        
        @pytest.mark.parametrize("n,expected", [
            (0, 1),
            (1, 1),
            (2, 2),
            (3, 6),
            (4, 24)
        ])
        def test_factorial_pytest(self, n, expected):
            """pytest参数化阶乘测试"""
            assert factorial(n) == expected

# 运行第三方库参数化测试
def run_third_party_parameterized_tests():
    """运行第三方库参数化测试"""
    if not PARAMETERIZED_AVAILABLE:
        print("parameterized库未安装，无法运行相关测试")
        return
    
    print("=== 运行第三方库参数化测试 ===")
    
    suite = unittest.TestLoader().loadTestsFromTestCase(TestWithParameterized)
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    print(f"\n第三方库参数化测试结果:")
    print(f"  运行: {result.testsRun} 个测试")
    print(f"  失败: {len(result.failures)} 个")
    print(f"  错误: {len(result.errors)} 个")

# 运行第三方库参数化测试演示
# run_third_party_parameterized_tests()
'''
    
    print("   第三方库参数化测试代码:")
    print(third_party_parameterized_code)
    
    # 3. 实际应用演示
    print("\n3. 实际应用演示:")
    
    # 被测试的函数
    def demo_is_prime(n):
        """判断是否为质数"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        
        for i in range(3, int(n**0.5) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    # 参数化测试类
    class TestDemoParameterized(unittest.TestCase):
        def test_prime_numbers(self):
            """测试质数"""
            prime_cases = [(2, True), (3, True), (5, True), (7, True), (11, True)]
            
            for number, expected in prime_cases:
                with self.subTest(number=number):
                    result = demo_is_prime(number)
                    self.assertEqual(result, expected)
        
        def test_composite_numbers(self):
            """测试合数"""
            composite_cases = [(4, False), (6, False), (8, False), (9, False), (10, False)]
            
            for number, expected in composite_cases:
                with self.subTest(number=number):
                    result = demo_is_prime(number)
                    self.assertEqual(result, expected)
    
    # 运行演示测试
    suite = unittest.TestLoader().loadTestsFromTestCase(TestDemoParameterized)
    runner = unittest.TextTestRunner(verbosity=0, stream=open(os.devnull, 'w'))
    result = runner.run(suite)
    
    print(f"   参数化演示测试结果:")
    print(f"     运行测试: {result.testsRun} 个")
    print(f"     子测试: 10 个 (5个质数 + 5个合数)")
    print(f"     成功: {result.testsRun - len(result.failures) - len(result.errors)} 个")
    print(f"     失败: {len(result.failures)} 个")
    print(f"     错误: {len(result.errors)} 个")
    
    print("\n   ✓ 参数化测试演示完成")

# 运行参数化测试演示
parameterized_tests_demo()
```