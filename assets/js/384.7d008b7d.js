(window.webpackJsonp=window.webpackJsonp||[]).push([[384],{1206:function(e,t,n){"use strict";n.r(t);var r=n(1),i=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("点击勘误"),t("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[e._v("issues"),t("OutboundLink")],1),e._v("，哪吒感谢大家的阅读")])]),e._v(" "),t("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),e._v(" "),t("h2",{attrs:{id:"过滤器、拦截器、监听器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#过滤器、拦截器、监听器"}},[e._v("#")]),e._v(" 过滤器、拦截器、监听器")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9B%91%E5%90%AC%E5%99%A8"}},[e._v("过滤器、拦截器、监听器")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#%E6%8B%A6%E6%88%AA%E5%99%A8"}},[e._v("拦截器")])])]),e._v(" "),t("ol",[t("li",[e._v("过滤器（Filter）：当有一堆请求，只希望符合预期的请求进来。")]),e._v(" "),t("li",[e._v("拦截器（Interceptor）：想要干涉预期的请求。")]),e._v(" "),t("li",[e._v("监听器（Listener）：想要监听这些请求具体做了什么。")])]),e._v(" "),t("p",[e._v("过滤器是在请求进入容器后，但还没有进入 Servlet 之前进行预处理的。")]),e._v(" "),t("p",[e._v("拦截器是在请求进入控制器（Controller） 之前进行预处理的。")]),e._v(" "),t("p",[e._v("虚线内就是过滤器和拦截器的作用范围：")]),e._v(" "),t("p",[e._v("过滤器依赖于 Servlet 容器，而拦截器依赖于 Spring 的 IoC 容器，因此可以通过注入的方式获取容器当中的对象。")]),e._v(" "),t("p",[e._v("监听器用于监听 Web 应用中某些对象的创建、销毁、增加、修改、删除等动作，然后做出相应的处理。")]),e._v(" "),t("p",[e._v("EE 过滤器")]),e._v(" "),t("ol",[t("li",[e._v("过滤敏感词汇（防止sql注入）")]),e._v(" "),t("li",[e._v("设置字符编码")]),e._v(" "),t("li",[e._v("URL级别的权限访问控制")]),e._v(" "),t("li",[e._v("压缩响应信息")])]),e._v(" "),t("p",[e._v("过滤器的创建和销毁都由 Web 服务器负责，Web 应用程序启动的时候，创建过滤器对象，为后续的请求过滤做好准备。")]),e._v(" "),t("p",[e._v("过滤器可以有很多个，一个个过滤器组合起来就成了 FilterChain，也就是过滤器链。")]),e._v(" "),t("p",[e._v("在 Spring 中，过滤器都默认继承了 OncePerRequestFilter，顾名思义，OncePerRequestFilter 的作用就是确保一次请求只通过一次过滤器，而不重复执行。")]),e._v(" "),t("p",[e._v("通过继承 OncePerRequestFilter 来实现 JWT 登录授权过滤的。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\n\t@Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain chain) throws ServletException, IOException {\n        // 从客户端请求中获取 JWT\n        String authHeader = request.getHeader(this.tokenHeader);\n        // 该 JWT 是我们规定的格式，以 tokenHead 开头\n        if (authHeader != null && authHeader.startsWith(this.tokenHead)) {\n            // The part after "Bearer "\n            String authToken = authHeader.substring(this.tokenHead.length());\n            // 从 JWT 中获取用户名\n            String username = jwtTokenUtil.getUserNameFromToken(authToken);\n            LOGGER.info("checking username:{}", username);\n\n            // SecurityContextHolder 是 SpringSecurity 的一个工具类\n            // 保存应用程序中当前使用人的安全上下文\n            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\n                // 根据用户名获取登录用户信息\n                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);\n                // 验证 token 是否过期\n                if (jwtTokenUtil.validateToken(authToken, userDetails)) {\n                    // 将登录用户保存到安全上下文中\n                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails,\n                            null, userDetails.getAuthorities());\n                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n                    SecurityContextHolder.getContext().setAuthentication(authentication);\n                }\n            }\n        }\n        chain.doFilter(request, response);\n    }\n}\n')])])]),t("p",[e._v("我们利用 Spring Initializr 来新建一个 Web 项目 codingmore-filter-interceptor-listener。")]),e._v(" "),t("p",[e._v("添加一个过滤器 MyFilter ：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('@WebFilter(urlPatterns = "/*", filterName = "myFilter")\npublic class MyFilter implements Filter {\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        Filter.super.init(filterConfig);\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        long start = System.currentTimeMillis();\n        chain.doFilter(request,response);\n        System.out.println("Execute cost="+(System.currentTimeMillis()-start));\n    }\n\n    @Override\n    public void destroy() {\n        Filter.super.destroy();\n    }\n}\n')])])]),t("p",[e._v("@WebFilter 注解用于将一个类声明为过滤器，urlPatterns 属性用来指定过滤器的 URL 匹配模式，filterName 用来定义过滤器的名字。")]),e._v(" "),t("p",[e._v("MyFilter 过滤器的逻辑非常简单，重写了 Filter 的三个方法，在 doFilter 方法中加入了时间戳的记录。")]),e._v(" "),t("p",[e._v("然后我们在项目入口类上加上 @ServletComponentScan 注解，这样过滤器就会自动注册。")]),e._v(" "),t("p",[e._v("启动服务器，访问任意的 URL。")]),e._v(" "),t("h2",{attrs:{id:"拦截器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拦截器"}},[e._v("#")]),e._v(" 拦截器")]),e._v(" "),t("ol",[t("li",[e._v("登录验证，判断用户是否登录")]),e._v(" "),t("li",[e._v("权限验证，判断用户是否有权限访问资源，如校验token")]),e._v(" "),t("li",[e._v("日志记录，记录请求操作日志（用户ip，访问时间等），以便统计请求访问量")]),e._v(" "),t("li",[e._v("处理cookie、本地化、国际化、主题等")]),e._v(" "),t("li",[e._v("性能监控，监控请求处理时长等")])]),e._v(" "),t("p",[e._v("我们来写一个简单的拦截器 LoggerInterceptor：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('@Slf4j\npublic class LoggerInterceptor implements HandlerInterceptor {\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        log.info("preHandle{}...",request.getRequestURI());\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);\n    }\n}\n')])])]),t("p",[e._v("一个拦截器必须实现 HandlerInterceptor 接口，preHandle 方法是 Controller 方法调用前执行，postHandle 是 Controller 方法正常返回后执行，afterCompletion 方法无论 Controller 方法是否抛异常都会执行。")]),e._v(" "),t("p",[e._v("只有 preHandle 返回 true 的话，其他两个方法才会执行。")]),e._v(" "),t("p",[e._v("如果 preHandle 返回 false 的话，表示不需要调用Controller方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。")]),e._v(" "),t("p",[e._v("再来一个 InterceptorConfig 对拦截器进行配置：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('@Configuration\npublic class InterceptorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoggerInterceptor()).addPathPatterns("/**");\n    }\n}\n')])])]),t("p",[e._v("@Configuration 注解用于定义配置类，干掉了以往 Spring 繁琐的 xml 配置文件。")])])}),[],!1,null,null,null);t.default=i.exports}}]);