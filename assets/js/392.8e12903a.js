(window.webpackJsonp=window.webpackJsonp||[]).push([[392],{1218:function(e,n,t){"use strict";t.r(n);var a=t(1),r=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("blockquote",[n("p",[e._v("点击勘误"),n("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[e._v("issues"),n("OutboundLink")],1),e._v("，哪吒感谢大家的阅读")])]),e._v(" "),n("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),e._v(" "),n("h2",{attrs:{id:"超详细netty入门"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#超详细netty入门"}},[e._v("#")]),e._v(" 超详细Netty入门")]),e._v(" "),n("p",[e._v("Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。")]),e._v(" "),n("p",[e._v("从官网上介绍，Netty是一个网络应用程序框架，开发服务器和客户端。也就是用于网络编程的一个框架。既然是网络编程，Socket就不谈了，为什么不用NIO呢？")]),e._v(" "),n("h3",{attrs:{id:"nio的缺点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nio的缺点"}},[e._v("#")]),e._v(" NIO的缺点")]),e._v(" "),n("p",[e._v("NIO的类库和API繁杂，学习成本高，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。")]),e._v(" "),n("p",[e._v("需要熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。")]),e._v(" "),n("h3",{attrs:{id:"netty的优点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#netty的优点"}},[e._v("#")]),e._v(" Netty的优点")]),e._v(" "),n("p",[e._v("相对地，Netty的优点有很多：")]),e._v(" "),n("ul",[n("li",[e._v("API使用简单，学习成本低。")]),e._v(" "),n("li",[e._v("功能强大，内置了多种解码编码器，支持多种协议。")]),e._v(" "),n("li",[e._v("性能高，对比其他主流的NIO框架，Netty的性能最优。")]),e._v(" "),n("li",[e._v("社区活跃，发现BUG会及时修复，迭代版本周期短，不断加入新的功能。")]),e._v(" "),n("li",[e._v("Dubbo、Elasticsearch都采用了Netty，质量得到验证。")])]),e._v(" "),n("p",[e._v("绿色的部分Core核心模块，包括零拷贝、API库、可扩展的事件模型。")]),e._v(" "),n("p",[e._v("橙色部分Protocol Support协议支持，包括Http协议、webSocket、SSL(安全套接字协议)、谷歌Protobuf协议、zlib/gzip压缩与解压缩、Large File Transfer大文件传输等等。")]),e._v(" "),n("p",[e._v("红色的部分Transport Services传输服务，包括Socket、Datagram、Http Tunnel等等。")]),e._v(" "),n("p",[e._v("以上可看出Netty的功能、协议、传输方式都比较全，比较强大。")]),e._v(" "),n("p",[e._v("引入Maven依赖")]),e._v(" "),n("p",[e._v("使用的版本是4.1.20，相对比较稳定的一个版本。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("<dependency>\n\t<groupId>io.netty</groupId>\n\t<artifactId>netty-all</artifactId>\n\t<version>4.1.20.Final</version>\n</dependency>\n")])])]),n("h3",{attrs:{id:"建服务端启动类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#建服务端启动类"}},[e._v("#")]),e._v(" 建服务端启动类")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class MyServer {\n    public static void main(String[] args) throws Exception {\n        //创建两个线程组 boosGroup、workerGroup\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            //创建服务端的启动对象，设置参数\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            //设置两个线程组boosGroup和workerGroup\n            bootstrap.group(bossGroup, workerGroup)\n                //设置服务端通道实现类型    \n                .channel(NioServerSocketChannel.class)\n                //设置线程队列得到连接个数    \n                .option(ChannelOption.SO_BACKLOG, 128)\n                //设置保持活动连接状态    \n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                //使用匿名内部类的形式初始化通道对象    \n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n                            //给pipeline管道设置处理器\n                            socketChannel.pipeline().addLast(new MyServerHandler());\n                        }\n                    });//给workerGroup的EventLoop对应的管道设置处理器\n            System.out.println("java技术爱好者的服务端已经准备就绪...");\n            //绑定端口号，启动服务端\n            ChannelFuture channelFuture = bootstrap.bind(6666).sync();\n            //对关闭通道进行监听\n            channelFuture.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}\n')])])]),n("h3",{attrs:{id:"创建服务端处理器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建服务端处理器"}},[e._v("#")]),e._v(" 创建服务端处理器")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('/**\n * 自定义的Handler需要继承Netty规定好的HandlerAdapter\n * 才能被Netty框架所关联，有点类似SpringMVC的适配器模式\n **/\npublic class MyServerHandler extends ChannelInboundHandlerAdapter {\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        //获取客户端发送过来的消息\n        ByteBuf byteBuf = (ByteBuf) msg;\n        System.out.println("收到客户端" + ctx.channel().remoteAddress() + "发送的消息：" + byteBuf.toString(CharsetUtil.UTF_8));\n    }\n\n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n        //发送消息给客户端\n        ctx.writeAndFlush(Unpooled.copiedBuffer("服务端已收到消息，并给你发送一个问号?", CharsetUtil.UTF_8));\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        //发生异常，关闭通道\n        ctx.close();\n    }\n}\n')])])]),n("h3",{attrs:{id:"创建客户端启动类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建客户端启动类"}},[e._v("#")]),e._v(" 创建客户端启动类")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class MyClient {\n\n    public static void main(String[] args) throws Exception {\n        NioEventLoopGroup eventExecutors = new NioEventLoopGroup();\n        try {\n            //创建bootstrap对象，配置参数\n            Bootstrap bootstrap = new Bootstrap();\n            //设置线程组\n            bootstrap.group(eventExecutors)\n                //设置客户端的通道实现类型    \n                .channel(NioSocketChannel.class)\n                //使用匿名内部类初始化通道\n                .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            //添加客户端通道的处理器\n                            ch.pipeline().addLast(new MyClientHandler());\n                        }\n                    });\n            System.out.println("客户端准备就绪，随时可以起飞~");\n            //连接服务端\n            ChannelFuture channelFuture = bootstrap.connect("127.0.0.1", 6666).sync();\n            //对通道关闭进行监听\n            channelFuture.channel().closeFuture().sync();\n        } finally {\n            //关闭线程组\n            eventExecutors.shutdownGracefully();\n        }\n    }\n}\n')])])]),n("h3",{attrs:{id:"创建客户端处理器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建客户端处理器"}},[e._v("#")]),e._v(" 创建客户端处理器")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class MyClientHandler extends ChannelInboundHandlerAdapter {\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        //发送消息到服务端\n        ctx.writeAndFlush(Unpooled.copiedBuffer("歪比巴卜~茉莉~Are you good~马来西亚~", CharsetUtil.UTF_8));\n    }\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        //接收服务端发送过来的消息\n        ByteBuf byteBuf = (ByteBuf) msg;\n        System.out.println("收到服务端" + ctx.channel().remoteAddress() + "的消息：" + byteBuf.toString(CharsetUtil.UTF_8));\n    }\n}\n')])])]),n("h2",{attrs:{id:"netty的特性与重要组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#netty的特性与重要组件"}},[e._v("#")]),e._v(" Netty的特性与重要组件")]),e._v(" "),n("p",[e._v("taskQueue任务队列")]),e._v(" "),n("p",[e._v("如果Handler处理器有一些长时间的业务处理，可以交给taskQueue异步处理。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class MyServerHandler extends ChannelInboundHandlerAdapter {\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        //获取到线程池eventLoop，添加线程，执行\n        ctx.channel().eventLoop().execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    //长时间操作，不至于长时间的业务操作导致Handler阻塞\n                    Thread.sleep(1000);\n                    System.out.println("长时间的业务处理");\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n}\n')])])]),n("p",[e._v("scheduleTaskQueue延时任务队列")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('ctx.channel().eventLoop().schedule(new Runnable() {\n    @Override\n    public void run() {\n        try {\n            //长时间操作，不至于长时间的业务操作导致Handler阻塞\n            Thread.sleep(1000);\n            System.out.println("长时间的业务处理");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n},5, TimeUnit.SECONDS);//5秒后执行\n')])])]),n("h3",{attrs:{id:"future异步机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#future异步机制"}},[e._v("#")]),e._v(" Future异步机制")]),e._v(" "),n("p",[e._v("在搭建HelloWord工程的时候，我们看到有一行这样的代码：")]),e._v(" "),n("p",[e._v('ChannelFuture channelFuture = bootstrap.connect("127.0.0.1", 6666);\n很多操作都返回这个ChannelFuture对象，究竟这个ChannelFuture对象是用来做什么的呢？')]),e._v(" "),n("p",[e._v("ChannelFuture提供操作完成时一种异步通知的方式。一般在Socket编程中，等待响应结果都是同步阻塞的，而Netty则不会造成阻塞，因为ChannelFuture是采取类似观察者模式的形式进行获取结果。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//添加监听器\nchannelFuture.addListener(new ChannelFutureListener() {\n    //使用匿名内部类，ChannelFutureListener接口\n    //重写operationComplete方法\n    @Override\n    public void operationComplete(ChannelFuture future) throws Exception {\n        //判断是否操作成功    \n        if (future.isSuccess()) {\n            System.out.println("连接成功");\n        } else {\n            System.out.println("连接失败");\n        }\n    }\n});\n')])])]),n("h2",{attrs:{id:"bootstrap与serverbootstrap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bootstrap与serverbootstrap"}},[e._v("#")]),e._v(" Bootstrap与ServerBootStrap")]),e._v(" "),n("p",[e._v("Bootstrap和ServerBootStrap是Netty提供的一个创建客户端和服务端启动器的工厂类，使用这个工厂类非常便利地创建启动类")]),e._v(" "),n("p",[e._v("可以看出都是继承于AbstractBootStrap抽象类，所以大致上的配置方法都相同。")]),e._v(" "),n("p",[e._v("bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并把连接注册到workerGroup的Selector中。")]),e._v(" "),n("p",[e._v("workerGroup用于处理每一个连接发生的读写事件。")]),e._v(" "),n("p",[e._v("一般创建线程组直接使用以下new就完事了：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("EventLoopGroup bossGroup = new NioEventLoopGroup();\nEventLoopGroup workerGroup = new NioEventLoopGroup();\n")])])]),n("p",[e._v("有点好奇的是，既然是线程组，那线程数默认是多少呢？深入源码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//使用一个常量保存\n    private static final int DEFAULT_EVENT_LOOP_THREADS;\n\n    static {\n        //NettyRuntime.availableProcessors() * 2，cpu核数的两倍赋值给常量\n        DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(\n                "io.netty.eventLoopThreads", NettyRuntime.availableProcessors() * 2));\n\n        if (logger.isDebugEnabled()) {\n            logger.debug("-Dio.netty.eventLoopThreads: {}", DEFAULT_EVENT_LOOP_THREADS);\n        }\n    }\n    \n    protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {\n        //如果不传入，则使用常量的值，也就是cpu核数的两倍\n        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);\n    }\n')])])]),n("p",[e._v("通过源码可以看到，默认的线程数是cpu核数的两倍。")]),e._v(" "),n("p",[e._v("channel()")]),e._v(" "),n("p",[e._v("这个方法用于设置通道类型，当建立连接后，会根据这个设置创建对应的Channel实例。")]),e._v(" "),n("p",[e._v("NioSocketChannel： 异步非阻塞的客户端 TCP Socket 连接。")]),e._v(" "),n("p",[e._v("NioServerSocketChannel： 异步非阻塞的服务器端 TCP Socket 连接。")]),e._v(" "),n("p",[e._v("常用的就是这两个通道类型，因为是异步非阻塞的。所以是首选。")]),e._v(" "),n("p",[e._v("OioSocketChannel： 同步阻塞的客户端 TCP Socket 连接。")]),e._v(" "),n("p",[e._v("OioServerSocketChannel： 同步阻塞的服务器端 TCP Socket 连接")]),e._v(" "),n("h3",{attrs:{id:"option-与childoption"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#option-与childoption"}},[e._v("#")]),e._v(" option()与childOption()")]),e._v(" "),n("p",[e._v("option()设置的是服务端用于接收进来的连接，也就是boosGroup线程。")]),e._v(" "),n("p",[e._v("childOption()是提供给父管道接收到的连接，也就是workerGroup线程。")]),e._v(" "),n("p",[e._v("SocketChannel参数，也就是childOption()常用的参数：")]),e._v(" "),n("p",[e._v("SO_RCVBUF Socket参数，TCP数据接收缓冲区大小。")]),e._v(" "),n("p",[e._v("TCP_NODELAY TCP参数，立即发送数据，默认值为Ture。")]),e._v(" "),n("p",[e._v("SO_KEEPALIVE Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。")]),e._v(" "),n("p",[e._v("ServerSocketChannel参数，也就是option()常用参数：")]),e._v(" "),n("p",[e._v("SO_BACKLOG Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。")]),e._v(" "),n("h2",{attrs:{id:"设置流水线-重点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#设置流水线-重点"}},[e._v("#")]),e._v(" 设置流水线(重点)")]),e._v(" "),n("p",[e._v("ChannelPipeline是Netty处理请求的责任链，ChannelHandler则是具体处理请求的处理器。实际上每一个channel都有一个处理器的流水线。")]),e._v(" "),n("p",[e._v("在Bootstrap中childHandler()方法需要初始化通道，实例化一个ChannelInitializer，这时候需要重写initChannel()初始化通道的方法，装配流水线就是在这个地方进行。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//使用匿名内部类的形式初始化通道对象\nbootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n    @Override\n    protected void initChannel(SocketChannel socketChannel) throws Exception {\n        //给pipeline管道设置自定义的处理器\n        socketChannel.pipeline().addLast(new MyServerHandler());\n    }\n});\n")])])]),n("p",[e._v("处理器Handler主要分为两种：")]),e._v(" "),n("p",[e._v("ChannelInboundHandlerAdapter(入站处理器)、ChannelOutboundHandler(出站处理器)")]),e._v(" "),n("p",[e._v("入站指的是数据从底层java NIO Channel到Netty的Channel。")]),e._v(" "),n("p",[e._v("出站指的是通过Netty的Channel来操作底层的java NIO Channel。")]),e._v(" "),n("p",[e._v("ChannelInboundHandlerAdapter处理器常用的事件有：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("注册事件 fireChannelRegistered。\n连接建立事件 fireChannelActive。\n读事件和读完成事件 fireChannelRead、fireChannelReadComplete。\n异常通知事件 fireExceptionCaught。\n用户自定义事件 fireUserEventTriggered。\nChannel 可写状态变化事件 fireChannelWritabilityChanged。\n连接关闭事件 fireChannelInactive。\n")])])]),n("p",[e._v("ChannelOutboundHandler处理器常用的事件有：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("端口绑定 bind。\n连接服务端 connect。\n写事件 write。\n刷新时间 flush。\n读事件 read。\n主动断开连接 disconnect。\n关闭 channel 事件 close。\n")])])]),n("h3",{attrs:{id:"bind"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bind"}},[e._v("#")]),e._v(" bind()")]),e._v(" "),n("p",[e._v("提供用于服务端或者客户端绑定服务器地址和端口号，默认是异步启动。如果加上sync()方法则是同步。")]),e._v(" "),n("p",[e._v("有五个同名的重载方法，作用都是用于绑定地址端口号。")]),e._v(" "),n("h3",{attrs:{id:"优雅地关闭eventloopgroup"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优雅地关闭eventloopgroup"}},[e._v("#")]),e._v(" 优雅地关闭EventLoopGroup")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("//释放掉所有的资源，包括创建的线程\nbossGroup.shutdownGracefully();\nworkerGroup.shutdownGracefully();\n")])])]),n("p",[e._v("会关闭所有的child Channel。关闭之后，释放掉底层的资源")]),e._v(" "),n("p",[e._v("一种连接到网络套接字或能进行读、写、连接和绑定等I/O操作的组件。")]),e._v(" "),n("p",[e._v("channel为用户提供：")]),e._v(" "),n("p",[e._v("通道当前的状态（例如它是打开？还是已连接？）")]),e._v(" "),n("p",[e._v("channel的配置参数（例如接收缓冲区的大小）")]),e._v(" "),n("p",[e._v("channel支持的IO操作（例如读、写、连接和绑定），以及处理与channel相关联的所有IO事件和请求的ChannelPipeline。")]),e._v(" "),n("h3",{attrs:{id:"selector"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#selector"}},[e._v("#")]),e._v(" Selector")]),e._v(" "),n("p",[e._v("在NioEventLoop中，有一个成员变量selector，这是nio包的Selector")]),e._v(" "),n("p",[e._v("Netty中的Selector也和NIO的Selector是一样的，就是用于监听事件，管理注册到Selector中的channel，实现多路复用器。")]),e._v(" "),n("h3",{attrs:{id:"pipeline与channelpipeline"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pipeline与channelpipeline"}},[e._v("#")]),e._v(" PiPeline与ChannelPipeline")]),e._v(" "),n("p",[e._v("在前面介绍Channel时，我们知道可以在channel中装配ChannelHandler流水线处理器，那一个channel不可能只有一个channelHandler处理器，肯定是有很多的，既然是很多channelHandler在一个流水线工作，肯定是有顺序的。")]),e._v(" "),n("p",[e._v("于是pipeline就出现了，pipeline相当于处理器的容器。初始化channel时，把channelHandler按顺序装在pipeline中，就可以实现按序执行channelHandler了。")]),e._v(" "),n("p",[e._v("在一个Channel中，只有一个ChannelPipeline。该pipeline在Channel被创建的时候创建。ChannelPipeline包含了一个ChannelHander形成的列表，且所有ChannelHandler都会注册到ChannelPipeline中。")]),e._v(" "),n("h3",{attrs:{id:"channelhandlercontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channelhandlercontext"}},[e._v("#")]),e._v(" ChannelHandlerContext")]),e._v(" "),n("p",[e._v("在Netty中，Handler处理器是有我们定义的，上面讲过通过集成入站处理器或者出站处理器实现。这时如果我们想在Handler中获取pipeline对象，或者channel对象，怎么获取呢。")]),e._v(" "),n("p",[e._v("于是Netty设计了这个ChannelHandlerContext上下文对象，就可以拿到channel、pipeline等对象，就可以进行读写等操作。")]),e._v(" "),n("p",[e._v("通过类图，ChannelHandlerContext是一个接口，下面有三个实现类。")]),e._v(" "),n("p",[e._v("实际上ChannelHandlerContext在pipeline中是一个链表的形式。")]),e._v(" "),n("p",[e._v("每个EventLoopGroup里包括一个或多个EventLoop，每个EventLoop中维护一个Selector实例。")]),e._v(" "),n("h3",{attrs:{id:"轮询机制的实现原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#轮询机制的实现原理"}},[e._v("#")]),e._v(" 轮询机制的实现原理")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("private final AtomicInteger idx = new AtomicInteger();\nprivate final EventExecutor[] executors;\n\n@Override\npublic EventExecutor next() {\n    //idx.getAndIncrement()相当于idx++，然后对任务长度取模\n    return executors[idx.getAndIncrement() & executors.length - 1];\n}\n")])])]),n("p",[e._v("它这里还有一个判断，如果线程数不是2的N次方，则采用取模算法实现。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Override\npublic EventExecutor next() {\n    return executors[Math.abs(idx.getAndIncrement() % executors.length)];\n}\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);