(window.webpackJsonp=window.webpackJsonp||[]).push([[214],{1008:function(t,e,v){"use strict";v.r(e);var s=v(1),_=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("blockquote",[e("p",[t._v("点击勘误"),e("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[t._v("issues"),e("OutboundLink")],1),t._v("，哪吒感谢大家的阅读")])]),t._v(" "),e("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),t._v(" "),e("h2",{attrs:{id:"封装继承多态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#封装继承多态"}},[t._v("#")]),t._v(" 封装继承多态")]),t._v(" "),e("p",[t._v("使用封装有 4 大好处：")]),t._v(" "),e("p",[t._v("1、良好的封装能够减少耦合。")]),t._v(" "),e("p",[t._v("2、类内部的结构可以自由修改。")]),t._v(" "),e("p",[t._v("3、可以对成员进行更精确的控制。")]),t._v(" "),e("p",[t._v("4、隐藏信息，实现细节。")]),t._v(" "),e("p",[t._v("继承的特点")]),t._v(" "),e("p",[t._v("继承的主要内容就是子类继承父类，并重写父类的方法。使用子类的属性或方法时候，首先要创建一个对象，而对象通过构造方法去创建，在构造方法中我们可能会调用子父类的一些属性和方法，所以就需要提前掌握 this 和 super 关键字。")]),t._v(" "),e("p",[t._v("this 表示当前对象，是指向自己的引用。")]),t._v(" "),e("p",[t._v("super 表示父类对象，是指向父类的引用。")]),t._v(" "),e("p",[t._v("访问修饰符")]),t._v(" "),e("p",[t._v("Java 子类重写继承的方法时，不可以降低方法的访问权限，子类继承父类的访问修饰符作用域不能比父类小，也就是更加开放，假如父类是 protected 修饰的，其子类只能是 protected 或者 public，绝对不能是 default(默认的访问范围)或者 private。所以在继承中需要重写的方法不能使用 private 修饰词修饰。")]),t._v(" "),e("p",[t._v("封装：是对类的封装，封装是对类的属性和方法进行封装，只对外暴露方法而不暴露具体使用细节，所以我们一般设计类成员变量时候大多设为私有而通过一些 get、set 方法去读写。")]),t._v(" "),e("p",[t._v("继承：子类继承父类，即“子承父业”，子类拥有父类除私有的所有属性和方法，自己还能在此基础上拓展自己新的属性和方法。主要目的是复用代码。")]),t._v(" "),e("p",[t._v("多态：多态是同一个行为具有多个不同表现形式或形态的能力。即一个父类可能有若干子类，各子类实现父类方法有多种多样，调用父类方法时，父类引用变量指向不同子类实例而执行不同方法，这就是所谓父类方法是多态的。")])])}),[],!1,null,null,null);e.default=_.exports}}]);