(window.webpackJsonp=window.webpackJsonp||[]).push([[379],{1197:function(e,s,t){"use strict";t.r(s);var a=t(1),v=Object(a.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("blockquote",[s("p",[e._v("点击勘误"),s("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[e._v("issues"),s("OutboundLink")],1),e._v("，哪吒感谢大家的阅读")])]),e._v(" "),s("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),e._v(" "),s("h2",{attrs:{id:"物联网redis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#物联网redis"}},[e._v("#")]),e._v(" 物联网redis")]),e._v(" "),s("p",[e._v("RedisConfig 是一个 Spring 配置类，主要用于配置连接 Redis 数据库并提供 RedisTemplate，它支持 Redis 作为实时缓存的备份存储。这段代码通过配置 Redis 连接池、主机地址、端口、密码、数据库索引等信息，确保应用能够连接到 Redis 并进行高效的缓存操作。")]),e._v(" "),s("h3",{attrs:{id:"主要功能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主要功能"}},[e._v("#")]),e._v(" 主要功能：")]),e._v(" "),s("p",[e._v("配置 Redis 连接参数：")]),e._v(" "),s("p",[e._v("通过 @Value 注解从配置文件中获取 Redis 相关的参数，如 Redis 主机地址、端口号、密码、数据库索引、超时时间等。")]),e._v(" "),s("p",[e._v("创建 Redis 连接工厂：")]),e._v(" "),s("p",[e._v("使用 JedisConnectionFactory 创建 Redis 连接工厂，连接到 Redis 实例并设置连接的各种参数，包括主机、端口、密码、数据库索引和超时时间。")]),e._v(" "),s("p",[e._v("配置 Redis 连接池：")]),e._v(" "),s("p",[e._v("使用 JedisPoolConfig 配置 Redis 连接池的相关参数，如最大空闲连接数 (maxIdle) 和最小空闲连接数 (minIdle)。连接池的使用有助于提升 Redis 连接的复用效率，避免每次都创建新的连接。")]),e._v(" "),s("p",[e._v("创建 RedisTemplate：")]),e._v(" "),s("p",[e._v("使用配置好的连接工厂来创建 RedisTemplate，这是 Spring 数据库操作的核心类之一，封装了对 Redis 的常见操作，如存取数据等。RedisTemplate 提供了对 Redis 数据库进行各种操作的 API。")]),e._v(" "),s("p",[e._v("日志输出：")]),e._v(" "),s("p",[e._v("配置过程中，输出日志，记录 Redis 主机地址、端口号等关键信息，用于调试和监控。")]),e._v(" "),s("p",[e._v("静态缓存设置：")]),e._v(" "),s("p",[e._v("Redis 主机、端口、数据库索引和密码构成的字符串，可能用于后续跟踪或缓存标识。")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("字段注入：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("  使用 @Value 注解，从配置文件中读取 Redis 的相关配置信息并赋值给类的成员变量：\n  host：Redis 主机地址。\n  port：Redis 端口号。\n  timeout：Redis 连接超时时间。\n  password：Redis 密码。\n  database：选择的 Redis 数据库索引。\n  maxIdle：连接池的最大空闲连接数。\n  minIdle：连接池的最小空闲连接数。\n")])])])])]),e._v(" "),s("p",[e._v("使用 "),s("code",[e._v("@ConfigurationProperties")]),e._v(" 进行批量注入：")]),e._v(" "),s("p",[e._v("使用 "),s("code",[e._v('@ConfigurationProperties(prefix = "xx.xx.redis")')]),e._v(" 来代替逐一的 "),s("code",[e._v("@Value")]),e._v(" 注入，简化了代码，提升了可扩展性。当有新的 Redis 配置项时，只需要在配置文件中新增对应字段，而不需要修改代码。")]),e._v(" "),s("p",[e._v("避免日志中输出敏感信息：")]),e._v(" "),s("p",[e._v("在日志中避免打印 Redis 密码。在设置 "),s("code",[e._v("rtCacheId")]),e._v(' 时，如果密码存在，使用 "****" 来替代真实的密码，这样可以避免将敏感信息泄露到日志中。')]),e._v(" "),s("p",[e._v("配置创建方法：")]),e._v(" "),s("p",[e._v("将连接工厂和连接池的创建逻辑提取到 "),s("code",[e._v("createJedisConnectionFactory()")]),e._v(" 和 "),s("code",[e._v("createJedisPoolConfig()")]),e._v(" 方法中，减少了重复代码，使得代码更加清晰和可维护。")]),e._v(" "),s("p",[e._v("连接池配置优化：")]),e._v(" "),s("p",[e._v("创建 "),s("code",[e._v("JedisPoolConfig")]),e._v(" 时将 "),s("code",[e._v("maxIdle")]),e._v(" 和 "),s("code",[e._v("minIdle")]),e._v(" 提取到单独的方法中，使得该部分配置更加清晰。")]),e._v(" "),s("p",[e._v("静态字段的使用：")]),e._v(" "),s("p",[e._v("rtCacheId 保留了静态变量，但请注意，在多线程环境下使用静态字段需要确保线程安全性。如果没有特殊需求，静态字段的使用应尽量避免。如果需要保证唯一标识，可以考虑使用单例模式或其他机制。")]),e._v(" "),s("p",[e._v("可扩展性：")]),e._v(" "),s("p",[e._v("使用 "),s("code",[e._v("@ConfigurationProperties")]),e._v(" 提高了类的可扩展性，方便以后扩展 "),s("code",[e._v("Redis")]),e._v(" 配置项。")]),e._v(" "),s("p",[e._v("简化日志记录：")]),e._v(" "),s("p",[e._v("日志记录中仅包含 "),s("code",[e._v("Redis")]),e._v(" 主机和端口，避免了敏感信息的暴露，同时对配置进行清晰描述。")]),e._v(" "),s("h2",{attrs:{id:"创建并配置一个-redistemplate-实例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建并配置一个-redistemplate-实例"}},[e._v("#")]),e._v(" 创建并配置一个 RedisTemplate 实例")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('redisTemplate.opsForValue().set("user:123:loginStatus", "active");\nString status = redisTemplate.opsForValue().get("user:123:loginStatus");\n\n// 消息发送\n\n// 获取返回结果\n\n// 获取实时数据\n')])])]),s("p",[e._v("实现了一个探测接口，用于获取 接入探测信息。虽然它能够完成任务，但在可维护性、性能、安全性、日志记录等方面仍有一些优化空间。以下是对该代码的优化建议以及优化后的代码：")]),e._v(" "),s("h2",{attrs:{id:"优化建议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化建议"}},[e._v("#")]),e._v(" 优化建议：")]),e._v(" "),s("h3",{attrs:{id:"日志增强"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#日志增强"}},[e._v("#")]),e._v(" 日志增强：")]),e._v(" "),s("p",[e._v("目前的日志输出过于简单，特别是请求参数部分，可能导致日志过于冗长。应该合理处理日志级别和敏感信息。")]),e._v(" "),s("h3",{attrs:{id:"异常处理改进"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异常处理改进"}},[e._v("#")]),e._v(" 异常处理改进：")]),e._v(" "),s("p",[e._v("异常捕获过于宽泛，捕获了所有异常。可以根据具体情况捕获特定的异常类型，例如 JsonProcessingException。")]),e._v(" "),s("h3",{attrs:{id:"方法拆分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方法拆分"}},[e._v("#")]),e._v(" 方法拆分：")]),e._v(" "),s("p",[e._v("info() 方法中的逻辑比较复杂，特别是与时间格式化、数据封装相关的部分，可以拆分成单独的辅助方法，减少方法复杂度。")]),e._v(" "),s("h3",{attrs:{id:"简化对象创建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简化对象创建"}},[e._v("#")]),e._v(" 简化对象创建：")]),e._v(" "),s("p",[e._v("ProbeInfo 对象的创建逻辑比较简单，直接使用构造函数来简化代码。不要重复设置相同属性。")]),e._v(" "),s("h3",{attrs:{id:"配置文件值的优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置文件值的优化"}},[e._v("#")]),e._v(" 配置文件值的优化：")]),e._v(" "),s("p",[e._v("配置文件中获取 spring.application.name 值的方式可以优化。建议使用 @ConfigurationProperties 代替 @Value，可以更方便地管理配置。")]),e._v(" "),s("h3",{attrs:{id:"线程安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程安全"}},[e._v("#")]),e._v(" 线程安全：")]),e._v(" "),s("p",[e._v("SimpleDateFormat 在多线程中是非线程安全的，考虑使用 "),s("code",[e._v("ThreadLocal<SimpleDateFormat>")]),e._v(" 来保证线程安全。")])])}),[],!1,null,null,null);s.default=v.exports}}]);