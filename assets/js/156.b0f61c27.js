(window.webpackJsonp=window.webpackJsonp||[]).push([[156],{949:function(e,n,a){"use strict";a.r(n);var t=a(1),s=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"hashmap底层原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hashmap底层原理"}},[e._v("#")]),e._v(" HashMap底层原理")]),e._v(" "),n("h2",{attrs:{id:"概述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),n("p",[e._v("HashMap是Java中最常用的数据结构之一，基于哈希表实现，提供O(1)的平均查找、插入和删除性能。本文深入分析HashMap的底层实现原理，包括数据结构、哈希算法、扩容机制、红黑树优化等核心技术。")]),e._v(" "),n("h2",{attrs:{id:"hashmap基本结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hashmap基本结构"}},[e._v("#")]),e._v(" HashMap基本结构")]),e._v(" "),n("h3",{attrs:{id:"核心属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#核心属性"}},[e._v("#")]),e._v(" 核心属性")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable {\n    \n    // 默认初始容量 16\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n    \n    // 最大容量\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n    \n    // 默认负载因子\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    \n    // 链表转红黑树的阈值\n    static final int TREEIFY_THRESHOLD = 8;\n    \n    // 红黑树转链表的阈值\n    static final int UNTREEIFY_THRESHOLD = 6;\n    \n    // 最小树化容量\n    static final int MIN_TREEIFY_CAPACITY = 64;\n    \n    // 存储数据的数组\n    transient Node<K,V>[] table;\n    \n    // 键值对数量\n    transient int size;\n    \n    // 结构修改次数\n    transient int modCount;\n    \n    // 扩容阈值\n    int threshold;\n    \n    // 负载因子\n    final float loadFactor;\n}\n")])])]),n("h3",{attrs:{id:"node节点结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#node节点结构"}},[e._v("#")]),e._v(" Node节点结构")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('static class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;    // 哈希值\n    final K key;       // 键\n    V value;           // 值\n    Node<K,V> next;    // 下一个节点\n    \n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n    \n    public final K getKey()        { return key; }\n    public final V getValue()      { return value; }\n    public final String toString() { return key + "=" + value; }\n    \n    public final int hashCode() {\n        return Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n    \n    public final V setValue(V newValue) {\n        V oldValue = value;\n        value = newValue;\n        return oldValue;\n    }\n    \n    public final boolean equals(Object o) {\n        if (o == this)\n            return true;\n        if (o instanceof Map.Entry) {\n            Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n            if (Objects.equals(key, e.getKey()) &&\n                Objects.equals(value, e.getValue()))\n                return true;\n        }\n        return false;\n    }\n}\n')])])]),n("h2",{attrs:{id:"哈希算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#哈希算法"}},[e._v("#")]),e._v(" 哈希算法")]),e._v(" "),n("h3",{attrs:{id:"hash-方法实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hash-方法实现"}},[e._v("#")]),e._v(" hash()方法实现")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("static final int hash(Object key) {\n    int h;\n    // key为null时返回0，否则计算hashCode并进行扰动\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n")])])]),n("p",[n("strong",[e._v("扰动函数设计原理：")])]),e._v(" "),n("ol",[n("li",[e._v("获取key的hashCode值")]),e._v(" "),n("li",[e._v("将hashCode的高16位与低16位进行异或运算")]),e._v(" "),n("li",[e._v("目的：让高位也参与到索引计算中，减少哈希冲突")])]),e._v(" "),n("h3",{attrs:{id:"索引计算"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#索引计算"}},[e._v("#")]),e._v(" 索引计算")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 计算数组索引\nint index = (table.length - 1) & hash;\n")])])]),n("p",[n("strong",[e._v("为什么使用位运算：")])]),e._v(" "),n("ul",[n("li",[e._v("HashMap的容量总是2的幂次方")]),e._v(" "),n("li",[n("code",[e._v("(n-1) & hash")]),e._v(" 等价于 "),n("code",[e._v("hash % n")]),e._v("，但位运算更快")]),e._v(" "),n("li",[e._v("例如：容量16，n-1=15(1111)，与任何hash值相与都能得到0-15的索引")])]),e._v(" "),n("h3",{attrs:{id:"哈希冲突解决"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#哈希冲突解决"}},[e._v("#")]),e._v(" 哈希冲突解决")]),e._v(" "),n("p",[e._v("HashMap使用"),n("strong",[e._v("链地址法")]),e._v("解决哈希冲突：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// JDK 1.8之前：纯链表结构\n// 数组 + 链表\n\n// JDK 1.8及之后：数组 + 链表 + 红黑树\n// 当链表长度超过8且数组长度大于64时，链表转换为红黑树\n")])])]),n("h2",{attrs:{id:"核心方法实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#核心方法实现"}},[e._v("#")]),e._v(" 核心方法实现")]),e._v(" "),n("h3",{attrs:{id:"put-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#put-方法"}},[e._v("#")]),e._v(" put()方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    \n    // 1. 如果table为空或长度为0，进行初始化\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    \n    // 2. 计算索引，如果该位置为空，直接插入\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; K k;\n        \n        // 3. 如果key已存在，记录该节点\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        \n        // 4. 如果是红黑树节点，调用红黑树插入方法\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        \n        // 5. 链表处理\n        else {\n            for (int binCount = 0; ; ++binCount) {\n                // 遍历到链表末尾，插入新节点\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    // 链表长度达到阈值，转换为红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1)\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                // 找到相同key，跳出循环\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        \n        // 6. 如果key已存在，更新value\n        if (e != null) {\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    \n    ++modCount;\n    // 7. 检查是否需要扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n")])])]),n("h3",{attrs:{id:"get-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#get-方法"}},[e._v("#")]),e._v(" get()方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    \n    // 1. 检查table是否为空，计算索引位置\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        \n        // 2. 检查第一个节点\n        if (first.hash == hash &&\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        \n        // 3. 如果有后续节点\n        if ((e = first.next) != null) {\n            // 红黑树查找\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            \n            // 链表查找\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n")])])]),n("h3",{attrs:{id:"remove-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#remove-方法"}},[e._v("#")]),e._v(" remove()方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public V remove(Object key) {\n    Node<K,V> e;\n    return (e = removeNode(hash(key), key, null, false, true)) == null ?\n        null : e.value;\n}\n\nfinal Node<K,V> removeNode(int hash, Object key, Object value,\n                           boolean matchValue, boolean movable) {\n    Node<K,V>[] tab; Node<K,V> p; int n, index;\n    \n    // 1. 检查table和目标位置\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (p = tab[index = (n - 1) & hash]) != null) {\n        \n        Node<K,V> node = null, e; K k; V v;\n        \n        // 2. 检查第一个节点\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            node = p;\n        \n        // 3. 查找目标节点\n        else if ((e = p.next) != null) {\n            if (p instanceof TreeNode)\n                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n            else {\n                do {\n                    if (e.hash == hash &&\n                        ((k = e.key) == key ||\n                         (key != null && key.equals(k)))) {\n                        node = e;\n                        break;\n                    }\n                    p = e;\n                } while ((e = e.next) != null);\n            }\n        }\n        \n        // 4. 删除节点\n        if (node != null && (!matchValue || (v = node.value) == value ||\n                             (value != null && value.equals(v)))) {\n            if (node instanceof TreeNode)\n                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n            else if (node == p)\n                tab[index] = node.next;\n            else\n                p.next = node.next;\n            ++modCount;\n            --size;\n            afterNodeRemoval(node);\n            return node;\n        }\n    }\n    return null;\n}\n")])])]),n("h2",{attrs:{id:"扩容机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#扩容机制"}},[e._v("#")]),e._v(" 扩容机制")]),e._v(" "),n("h3",{attrs:{id:"resize-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#resize-方法"}},[e._v("#")]),e._v(" resize()方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("final Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    \n    // 1. 计算新容量和新阈值\n    if (oldCap > 0) {\n        // 已达到最大容量\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 容量翻倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1;\n    }\n    else if (oldThr > 0)\n        newCap = oldThr;\n    else {\n        // 初始化\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    \n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    \n    threshold = newThr;\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    \n    // 2. 数据迁移\n    if (oldTab != null) {\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                \n                // 只有一个节点\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                \n                // 红黑树\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                \n                // 链表\n                else {\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    \n                    do {\n                        next = e.next;\n                        // 原索引\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        // 原索引 + oldCap\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    \n                    // 放置到新数组\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n")])])]),n("h3",{attrs:{id:"扩容优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#扩容优化"}},[e._v("#")]),e._v(" 扩容优化")]),e._v(" "),n("p",[n("strong",[e._v("JDK 1.8的扩容优化：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 扩容时，元素要么在原位置，要么在原位置+oldCap\n// 通过 (e.hash & oldCap) 判断：\n// - 结果为0：保持原索引\n// - 结果为1：新索引 = 原索引 + oldCap\n\n// 例如：oldCap = 16, newCap = 32\n// hash = 5:  5 & 16 = 0, 新索引 = 5\n// hash = 21: 21 & 16 = 16, 新索引 = 5 + 16 = 21\n")])])]),n("h2",{attrs:{id:"红黑树优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#红黑树优化"}},[e._v("#")]),e._v(" 红黑树优化")]),e._v(" "),n("h3",{attrs:{id:"treenode结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#treenode结构"}},[e._v("#")]),e._v(" TreeNode结构")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n    TreeNode<K,V> parent;  // 父节点\n    TreeNode<K,V> left;    // 左子节点\n    TreeNode<K,V> right;   // 右子节点\n    TreeNode<K,V> prev;    // 前驱节点（维护插入顺序）\n    boolean red;           // 颜色\n    \n    TreeNode(int hash, K key, V val, Node<K,V> next) {\n        super(hash, key, val, next);\n    }\n    \n    // 返回根节点\n    final TreeNode<K,V> root() {\n        for (TreeNode<K,V> r = this, p;;) {\n            if ((p = r.parent) == null)\n                return r;\n            r = p;\n        }\n    }\n}\n")])])]),n("h3",{attrs:{id:"链表转红黑树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#链表转红黑树"}},[e._v("#")]),e._v(" 链表转红黑树")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("final void treeifyBin(Node<K,V>[] tab, int hash) {\n    int n, index; Node<K,V> e;\n    \n    // 如果数组长度小于64，优先扩容而不是树化\n    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\n        resize();\n    else if ((e = tab[index = (n - 1) & hash]) != null) {\n        TreeNode<K,V> hd = null, tl = null;\n        \n        // 1. 将链表节点转换为树节点\n        do {\n            TreeNode<K,V> p = replacementTreeNode(e, null);\n            if (tl == null)\n                hd = p;\n            else {\n                p.prev = tl;\n                tl.next = p;\n            }\n            tl = p;\n        } while ((e = e.next) != null);\n        \n        // 2. 构建红黑树\n        if ((tab[index] = hd) != null)\n            hd.treeify(tab);\n    }\n}\n")])])]),n("h3",{attrs:{id:"红黑树查找"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#红黑树查找"}},[e._v("#")]),e._v(" 红黑树查找")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("final TreeNode<K,V> getTreeNode(int h, Object k) {\n    return ((parent != null) ? root() : this).find(h, k, null);\n}\n\nfinal TreeNode<K,V> find(int h, Object k, Class<?> kc) {\n    TreeNode<K,V> p = this;\n    do {\n        int ph, dir; K pk;\n        TreeNode<K,V> pl = p.left, pr = p.right, q;\n        \n        // 根据hash值比较\n        if ((ph = p.hash) > h)\n            p = pl;\n        else if (ph < h)\n            p = pr;\n        \n        // hash相等，比较key\n        else if ((pk = p.key) == k || (k != null && k.equals(pk)))\n            return p;\n        \n        // hash相等但key不等，继续查找\n        else if (pl == null)\n            p = pr;\n        else if (pr == null)\n            p = pl;\n        \n        // 使用Comparable接口比较\n        else if ((kc != null ||\n                  (kc = comparableClassFor(k)) != null) &&\n                 (dir = compareComparables(kc, k, pk)) != 0)\n            p = (dir < 0) ? pl : pr;\n        \n        // 递归查找\n        else if ((q = pr.find(h, k, kc)) != null)\n            return q;\n        else\n            p = pl;\n    } while (p != null);\n    return null;\n}\n")])])]),n("h2",{attrs:{id:"线程安全问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程安全问题"}},[e._v("#")]),e._v(" 线程安全问题")]),e._v(" "),n("h3",{attrs:{id:"并发问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#并发问题"}},[e._v("#")]),e._v(" 并发问题")]),e._v(" "),n("p",[n("strong",[e._v("1. 数据丢失")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// 两个线程同时put，可能导致数据丢失\nThread1: put("key1", "value1")\nThread2: put("key2", "value2")\n// 如果hash冲突，后执行的可能覆盖前面的\n')])])]),n("p",[n("strong",[e._v("2. 死循环（JDK 1.7）")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// JDK 1.7的扩容过程中，并发操作可能导致链表形成环\n// JDK 1.8通过改进扩容算法解决了这个问题\n")])])]),n("p",[n("strong",[e._v("3. 数据不一致")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 扩容过程中的读操作可能读到不一致的数据\n")])])]),n("h3",{attrs:{id:"解决方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[e._v("#")]),e._v(" 解决方案")]),e._v(" "),n("p",[n("strong",[e._v("1. Collections.synchronizedMap()")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Map<String, String> map = Collections.synchronizedMap(new HashMap<>());\n// 在每个方法上加synchronized，性能较差\n")])])]),n("p",[n("strong",[e._v("2. ConcurrentHashMap")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Map<String, String> map = new ConcurrentHashMap<>();\n// 使用分段锁（JDK 1.7）或CAS+synchronized（JDK 1.8）\n")])])]),n("p",[n("strong",[e._v("3. ThreadLocal")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("ThreadLocal<Map<String, String>> threadLocalMap = \n    ThreadLocal.withInitial(HashMap::new);\n// 每个线程独立的HashMap实例\n")])])]),n("h2",{attrs:{id:"性能优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[e._v("#")]),e._v(" 性能优化")]),e._v(" "),n("h3",{attrs:{id:"_1-初始容量设置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-初始容量设置"}},[e._v("#")]),e._v(" 1. 初始容量设置")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 根据预期元素数量设置初始容量\nint expectedSize = 1000;\nint initialCapacity = (int) (expectedSize / 0.75f) + 1;\nMap<String, String> map = new HashMap<>(initialCapacity);\n")])])]),n("h3",{attrs:{id:"_2-负载因子选择"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-负载因子选择"}},[e._v("#")]),e._v(" 2. 负载因子选择")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 默认负载因子0.75是时间和空间的折中\n// 更小的负载因子：更少冲突，更多内存\n// 更大的负载因子：更多冲突，更少内存\nMap<String, String> map = new HashMap<>(16, 0.6f);\n")])])]),n("h3",{attrs:{id:"_3-key的hashcode优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-key的hashcode优化"}},[e._v("#")]),e._v(" 3. key的hashCode优化")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class OptimizedKey {\n    private final String value;\n    private final int hashCode;\n    \n    public OptimizedKey(String value) {\n        this.value = value;\n        this.hashCode = value.hashCode(); // 缓存hashCode\n    }\n    \n    @Override\n    public int hashCode() {\n        return hashCode; // 直接返回缓存值\n    }\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (!(obj instanceof OptimizedKey)) return false;\n        OptimizedKey other = (OptimizedKey) obj;\n        return Objects.equals(value, other.value);\n    }\n}\n")])])]),n("h2",{attrs:{id:"实际应用场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实际应用场景"}},[e._v("#")]),e._v(" 实际应用场景")]),e._v(" "),n("h3",{attrs:{id:"_1-缓存实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-缓存实现"}},[e._v("#")]),e._v(" 1. 缓存实现")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private final int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75f, true);\n        this.capacity = capacity;\n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        return size() > capacity;\n    }\n}\n")])])]),n("h3",{attrs:{id:"_2-计数器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-计数器"}},[e._v("#")]),e._v(" 2. 计数器")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class Counter {\n    private final Map<String, Integer> counts = new HashMap<>();\n    \n    public void increment(String key) {\n        counts.merge(key, 1, Integer::sum);\n    }\n    \n    public int getCount(String key) {\n        return counts.getOrDefault(key, 0);\n    }\n}\n")])])]),n("h3",{attrs:{id:"_3-索引构建"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-索引构建"}},[e._v("#")]),e._v(" 3. 索引构建")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class InvertedIndex {\n    private final Map<String, Set<Integer>> index = new HashMap<>();\n    \n    public void addDocument(int docId, String content) {\n        String[] words = content.split("\\\\s+");\n        for (String word : words) {\n            index.computeIfAbsent(word.toLowerCase(), \n                k -> new HashSet<>()).add(docId);\n        }\n    }\n    \n    public Set<Integer> search(String word) {\n        return index.getOrDefault(word.toLowerCase(), \n            Collections.emptySet());\n    }\n}\n')])])]),n("h2",{attrs:{id:"版本演进"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#版本演进"}},[e._v("#")]),e._v(" 版本演进")]),e._v(" "),n("h3",{attrs:{id:"jdk-1-7-vs-jdk-1-8"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jdk-1-7-vs-jdk-1-8"}},[e._v("#")]),e._v(" JDK 1.7 vs JDK 1.8")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th",[e._v("特性")]),e._v(" "),n("th",[e._v("JDK 1.7")]),e._v(" "),n("th",[e._v("JDK 1.8")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("数据结构")]),e._v(" "),n("td",[e._v("数组+链表")]),e._v(" "),n("td",[e._v("数组+链表+红黑树")])]),e._v(" "),n("tr",[n("td",[e._v("插入方式")]),e._v(" "),n("td",[e._v("头插法")]),e._v(" "),n("td",[e._v("尾插法")])]),e._v(" "),n("tr",[n("td",[e._v("扩容优化")]),e._v(" "),n("td",[e._v("重新计算hash")]),e._v(" "),n("td",[e._v("位运算优化")])]),e._v(" "),n("tr",[n("td",[e._v("树化阈值")]),e._v(" "),n("td",[e._v("无")]),e._v(" "),n("td",[e._v("链表长度>8且数组长度>64")])]),e._v(" "),n("tr",[n("td",[e._v("并发安全")]),e._v(" "),n("td",[e._v("可能死循环")]),e._v(" "),n("td",[e._v("避免了死循环")])])])]),e._v(" "),n("h3",{attrs:{id:"关键改进"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关键改进"}},[e._v("#")]),e._v(" 关键改进")]),e._v(" "),n("p",[n("strong",[e._v("1. 红黑树优化")])]),e._v(" "),n("ul",[n("li",[e._v("最坏情况下查找时间复杂度从O(n)降到O(logn)")]),e._v(" "),n("li",[e._v("避免了恶意hash攻击")])]),e._v(" "),n("p",[n("strong",[e._v("2. 扩容优化")])]),e._v(" "),n("ul",[n("li",[e._v("避免重新计算hash值")]),e._v(" "),n("li",[e._v("保持链表顺序，避免死循环")])]),e._v(" "),n("p",[n("strong",[e._v("3. hash函数优化")])]),e._v(" "),n("ul",[n("li",[e._v("高16位参与运算，减少冲突")])]),e._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[e._v("HashMap的高效性能源于其精心设计的实现：")]),e._v(" "),n("ol",[n("li",[n("strong",[e._v("哈希算法")]),e._v("：扰动函数减少冲突，位运算提高性能")]),e._v(" "),n("li",[n("strong",[e._v("动态扩容")]),e._v("：保持合适的负载因子，优化的扩容算法")]),e._v(" "),n("li",[n("strong",[e._v("红黑树优化")]),e._v("：解决链表过长的性能问题")]),e._v(" "),n("li",[n("strong",[e._v("内存布局")]),e._v("：紧凑的数据结构，良好的缓存局部性")])]),e._v(" "),n("p",[e._v("理解HashMap的底层原理，有助于我们：")]),e._v(" "),n("ul",[n("li",[e._v("正确使用HashMap，避免性能陷阱")]),e._v(" "),n("li",[e._v("设计高质量的hashCode方法")]),e._v(" "),n("li",[e._v("选择合适的初始容量和负载因子")]),e._v(" "),n("li",[e._v("在并发场景下选择合适的替代方案")])]),e._v(" "),n("p",[e._v("HashMap作为Java集合框架的核心组件，其设计思想和优化技巧值得深入学习和借鉴。")])])}),[],!1,null,null,null);n.default=s.exports}}]);