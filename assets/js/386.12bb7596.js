(window.webpackJsonp=window.webpackJsonp||[]).push([[386],{1209:function(e,t,r){"use strict";r.r(t);var n=r(1),a=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("点击勘误"),t("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[e._v("issues"),t("OutboundLink")],1),e._v("，哪吒感谢大家的阅读")])]),e._v(" "),t("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),e._v(" "),t("h2",{attrs:{id:"缓冲流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓冲流"}},[e._v("#")]),e._v(" 缓冲流")]),e._v(" "),t("p",[e._v("Java 的缓冲流是对字节流和字符流的一种封装，通过在内存中开辟缓冲区来提高 I/O 操作的效率。Java 通过 BufferedInputStream 和 BufferedOutputStream 来实现字节流的缓冲，通过 BufferedReader 和 BufferedWriter 来实现字符流的缓冲。")]),e._v(" "),t("p",[e._v("缓冲流的工作原理是将数据先写入缓冲区中，当缓冲区满时再一次性写入文件或输出流，或者当缓冲区为空时一次性从文件或输入流中读取一定量的数据。这样可以减少系统的 I/O 操作次数，提高系统的 I/O 效率，从而提高程序的运行效率。")]),e._v(" "),t("h3",{attrs:{id:"_01、字节缓冲流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_01、字节缓冲流"}},[e._v("#")]),e._v(" 01、字节缓冲流")]),e._v(" "),t("p",[e._v("BufferedInputStream 和 BufferedOutputStream 属于字节缓冲流，强化了字节流 InputStream 和 OutputStream。")]),e._v(" "),t("h3",{attrs:{id:"_1-构造方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-构造方法"}},[e._v("#")]),e._v(" 1）构造方法")]),e._v(" "),t("ul",[t("li",[e._v("BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流，注意参数类型为InputStream。")]),e._v(" "),t("li",[e._v("BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流，注意参数类型为OutputStream。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 创建字节缓冲输入流，先声明字节流\nFileInputStream fps = new FileInputStream(b.txt);\nBufferedInputStream bis = new BufferedInputStream(fps)\n\n// 创建字节缓冲输入流（一步到位）\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream("b.txt"));\n\n// 创建字节缓冲输出流（一步到位）\nBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("b.txt"));\n')])])]),t("p",[e._v("3）为什么字节缓冲流会这么快？")]),e._v(" "),t("p",[e._v("传统的 Java IO 是阻塞模式的，它的工作状态就是“读/写，等待，读/写，等待。。。。。。”")]),e._v(" "),t("p",[e._v("字节缓冲流解决的就是这个问题：一次多读点多写点，减少读写的频率，用空间换时间。")]),e._v(" "),t("ul",[t("li",[e._v("减少系统调用次数：在使用字节缓冲流时，数据不是立即写入磁盘或输出流，而是先写入缓冲区，当缓冲区满时再一次性写入磁盘或输出流。这样可以减少系统调用的次数，从而提高 I/O 操作的效率。")]),e._v(" "),t("li",[e._v("减少磁盘读写次数：在使用字节缓冲流时，当需要读取数据时，缓冲流会先从缓冲区中读取数据，如果缓冲区中没有足够的数据，则会一次性从磁盘或输入流中读取一定量的数据。同样地，当需要写入数据时，缓冲流会先将数据写入缓冲区，如果缓冲区满了，则会一次性将缓冲区中的数据写入磁盘或输出流。这样可以减少磁盘读写的次数，从而提高 I/O 操作的效率。")]),e._v(" "),t("li",[e._v("提高数据传输效率：在使用字节缓冲流时，由于数据是以块的形式进行传输，因此可以减少数据传输的次数，从而提高数据传输的效率。")])]),e._v(" "),t("h3",{attrs:{id:"_02、字符缓冲流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_02、字符缓冲流"}},[e._v("#")]),e._v(" 02、字符缓冲流")]),e._v(" "),t("p",[e._v("BufferedReader 类继承自 Reader 类，提供了一些便捷的方法，例如 readLine() 方法可以一次读取一行数据，而不是一个字符一个字符地读取。")]),e._v(" "),t("p",[e._v("BufferedWriter 类继承自 Writer 类，提供了一些便捷的方法，例如 newLine() 方法可以写入一个系统特定的行分隔符。")]),e._v(" "),t("p",[e._v("1）构造方法")]),e._v(" "),t("ul",[t("li",[e._v("BufferedReader(Reader in) ：创建一个新的缓冲输入流，注意参数类型为Reader。")]),e._v(" "),t("li",[e._v("BufferedWriter(Writer out)： 创建一个新的缓冲输出流，注意参数类型为Writer。")])]),e._v(" "),t("p",[e._v("2）字符缓冲流特有方法")]),e._v(" "),t("p",[e._v("字符缓冲流的基本方法与普通字符流调用方式一致，这里不再赘述，我们来看字符缓冲流特有的方法。")]),e._v(" "),t("ul",[t("li",[e._v("BufferedReader：String readLine(): 读一行数据，读取到最后返回 null")]),e._v(" "),t("li",[e._v("BufferedWriter：newLine(): 换行，由系统定义换行符。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 创建map集合,保存文本数据,键为序号,值为文字\nHashMap<String, String> lineMap = new HashMap<>();\n\n// 创建流对象  源\nBufferedReader br = new BufferedReader(new FileReader("logs/test.log"));\n//目标\nBufferedWriter bw = new BufferedWriter(new FileWriter("logs/test1.txt"));\n\n// 读取数据\nString line;\nwhile ((line = br.readLine())!=null) {\n    // 解析文本\n    if (line.isEmpty()) {\n        continue;\n    }\n    String[] split = line.split(Pattern.quote("."));\n    // 保存到集合\n    lineMap.put(split[0], split[1]);\n}\n// 释放资源\nbr.close();\n\n// 遍历map集合\nfor (int i = 1; i <= lineMap.size(); i++) {\n    String key = String.valueOf(i);\n    // 获取map中文本\n    String value = lineMap.get(key);\n    // 写出拼接文本\n    bw.write(key+"."+value);\n    // 写出换行\n    bw.newLine();\n}\n// 释放资源\nbw.close();\n')])])])])}),[],!1,null,null,null);t.default=a.exports}}]);