(window.webpackJsonp=window.webpackJsonp||[]).push([[340],{1157:function(s,e,r){"use strict";r.r(e);var t=r(1),i=Object(t.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("blockquote",[e("p",[s._v("点击勘误"),e("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[s._v("issues"),e("OutboundLink")],1),s._v("，哪吒感谢大家的阅读")])]),s._v(" "),e("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),s._v(" "),e("h2",{attrs:{id:"redis如何高并发和高可用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis如何高并发和高可用"}},[s._v("#")]),s._v(" redis如何高并发和高可用")]),s._v(" "),e("p",[s._v("redis 单机能承载多高并发？如果单机扛不住如何扩容扛更多的并发？redis 会不会挂？既然 redis 会挂那怎么保证 redis 是高可用的？")]),s._v(" "),e("p",[s._v("考虑如何用 redis 来加多台机器，保证 redis 是高并发的，还有就是如何让 redis 保证自己不是挂掉以后就直接死掉了，即 redis 高可用。")]),s._v(" "),e("ol",[e("li",[s._v("redis 主从架构")]),s._v(" "),e("li",[s._v("redis 基于哨兵实现高可用")])]),s._v(" "),e("p",[s._v("redis 实现高并发主要依靠主从架构，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万 QPS，多从用来查询数据，多个从实例可以提供每秒 10w 的 QPS。")]),s._v(" "),e("p",[s._v("如果想要在实现高并发的同时，容纳大量的数据，那么就需要 redis 集群，使用 redis 集群之后，可以提供每秒几十万的读写并发。")]),s._v(" "),e("p",[s._v("redis 高可用，如果是做主从架构部署，那么加上哨兵就可以了，就可以实现，任何一个实例宕机，可以进行主备切换。")])])}),[],!1,null,null,null);e.default=i.exports}}]);