(window.webpackJsonp=window.webpackJsonp||[]).push([[400],{1228:function(e,n,t){"use strict";t.r(n);var r=t(1),a=Object(r.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("blockquote",[n("p",[e._v("点击勘误"),n("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[e._v("issues"),n("OutboundLink")],1),e._v("，哪吒感谢大家的阅读")])]),e._v(" "),n("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),e._v(" "),n("h2",{attrs:{id:"处理校验逻辑"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#处理校验逻辑"}},[e._v("#")]),e._v(" 处理校验逻辑")]),e._v(" "),n("p",[e._v("需要对请求参数进行校验，比如说非空啊、长度限制啊等等，可选的解决方案有两种：")]),e._v(" "),n("ol",[n("li",[e._v("一种是用 Hibernate Validator 来处理")]),e._v(" "),n("li",[e._v("一种是用全局异常来处理")])]),e._v(" "),n("h2",{attrs:{id:"一、hibernate-validator"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、hibernate-validator"}},[e._v("#")]),e._v(" 一、Hibernate Validator")]),e._v(" "),n("p",[e._v("Spring Boot 已经内置了 Hibernate Validator 校验框架，这个可以通过 Spring Boot 官网查看和确认。")]),e._v(" "),n("p",[e._v("第一步，进入 Spring Boot 官网，点击 learn 这个面板，点击参考文档。")]),e._v(" "),n("h2",{attrs:{id:"第二步-在参考文档页点击「依赖的版本」。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第二步-在参考文档页点击「依赖的版本」。"}},[e._v("#")]),e._v(" 第二步，在参考文档页点击「依赖的版本」。")]),e._v(" "),n("p",[e._v("第三步，在依赖版本页就可以查看到所有的依赖了，包括版本号。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<dependency>\n    <groupId>org.hibernate.validator</groupId>\n    <artifactId>hibernate-validator</artifactId>\n    <version>6.0.17.Final</version>\n</dependency>\n<dependency>\n    <groupId>javax.validation</groupId>\n    <artifactId>validation-api</artifactId>\n    <version>2.0.1.Final</version>\n</dependency>\n")])])]),n("p",[e._v("通过 Hibernate Validator 校验框架，我们可以直接在请求参数的字段上加入注解来完成校验。")]),e._v(" "),n("h2",{attrs:{id:"具体该怎么做呢"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#具体该怎么做呢"}},[e._v("#")]),e._v(" 具体该怎么做呢？")]),e._v(" "),n("p",[e._v("第一步，在需要验证的字段上加上 Hibernate Validator 提供的校验注解。")]),e._v(" "),n("p",[e._v("比如说我现在有一个用户名和密码登录的请求参数 UsersLoginParam 类：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Data\n@ApiModel(value="用户登录", description="用户表")\npublic class UsersLoginParam implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    @ApiModelProperty(value = "登录名")\n    @NotBlank(message="登录名不能为空")\n    private String userLogin;\n\n    @ApiModelProperty(value = "密码")\n    @NotBlank(message="密码不能为空")\n    private String userPass;\n}\n')])])]),n("p",[e._v("就可以通过 @NotBlank 注解来对用户名和密码进行判空校验。除了 @NotBlank 注解，Hibernate Validator 还提供了以下常用注解：")]),e._v(" "),n("ol",[n("li",[e._v("@NotNull：被注解的字段不能为 null；")]),e._v(" "),n("li",[e._v("@NotEmpty：被注解的字段不能为空；")]),e._v(" "),n("li",[e._v("@Min：被注解的字段必须大于等于其value值；")]),e._v(" "),n("li",[e._v("@Max：被注解的字段必须小于等于其value值；")]),e._v(" "),n("li",[e._v("@Size：被注解的字段必须在其min和max值之间；")]),e._v(" "),n("li",[e._v("@Pattern：被注解的字段必须符合所定义的正则表达式；")]),e._v(" "),n("li",[e._v("@Email：被注解的字段必须符合邮箱格式。")])]),e._v(" "),n("p",[e._v("第二步，在对应的请求接口（UsersController.login()）中添加 @Validated 注解，并注入一个 BindingResult 参数。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Controller\n@Api(tags="用户")\n@RequestMapping("/users")\npublic class UsersController {\n    @Autowired\n    private IUsersService usersService;\n\n    @ApiOperation(value = "登录以后返回token")\n    @RequestMapping(value = "/login", method = RequestMethod.POST)\n    @ResponseBody\n    public ResultObject login(@Validated UsersLoginParam users, BindingResult result) {\n        String token = usersService.login(users.getUserLogin(), users.getUserPass());\n        if (token == null) {\n            return ResultObject.validateFailed("用户名或密码错误");\n        }\n        Map<String, String> tokenMap = new HashMap<>();\n        tokenMap.put("token", token);\n        tokenMap.put("tokenHead", tokenHead);\n        return ResultObject.success(tokenMap);\n    }\n}\n')])])]),n("p",[e._v("第三步，为控制层（UsersController）创建一个切面，将通知注入到 BindingResult 对象中，然后再判断是否有校验错误，有错误的话返回校验提示信息，否则放行。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Aspect\n@Component\n@Order(2)\npublic class BindingResultAspect {\n    @Pointcut("execution(public * com.codingmore.controller.*.*(..))")\n    public void BindingResult() {\n    }\n\n    @Around("BindingResult()")\n    public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {\n        Object[] args = joinPoint.getArgs();\n        for (Object arg : args) {\n            if (arg instanceof BindingResult) {\n                BindingResult result = (BindingResult) arg;\n                if (result.hasErrors()) {\n                    FieldError fieldError = result.getFieldError();\n                    if(fieldError!=null){\n                        return ResultObject.validateFailed(fieldError.getDefaultMessage());\n                    }else{\n                        return ResultObject.validateFailed();\n                    }\n                }\n            }\n        }\n        return joinPoint.proceed();\n    }\n}\n')])])]),n("p",[e._v("可以看得出，Hibernate Validator 带来的优势有这些：")]),e._v(" "),n("ol",[n("li",[e._v("验证逻辑与业务逻辑进行了分离，降低了程序耦合度；")]),e._v(" "),n("li",[e._v("统一且规范的验证方式，无需再次编写重复的验证代码。")])]),e._v(" "),n("p",[e._v("不过，也带来一些弊端，比如说：")]),e._v(" "),n("ol",[n("li",[e._v("需要在请求接口的方法中注入 BindingResult 对象，而这个对应在方法体中并没有用到")]),e._v(" "),n("li",[e._v("只能校验一些非常简单的逻辑，涉及到数据查询就无能为力了。")])]),e._v(" "),n("p",[e._v("二、全局异常处理")]),e._v(" "),n("p",[e._v("使用全局异常处理的优点就是比较灵活，可以处理比较复杂的逻辑校验，在校验失败的时候直接抛出异常，然后进行捕获处理就可以了。")]),e._v(" "),n("p",[e._v("第一步，新建一个自定义异常类 ApiException。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class ApiException extends RuntimeException {\n    private IErrorCode errorCode;\n\n    public ApiException(IErrorCode errorCode) {\n        super(errorCode.getMessage());\n        this.errorCode = errorCode;\n    }\n\n    public ApiException(String message) {\n        super(message);\n    }\n\n    public ApiException(Throwable cause) {\n        super(cause);\n    }\n\n    public ApiException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    public IErrorCode getErrorCode() {\n        return errorCode;\n    }\n}\n")])])]),n("p",[e._v("第二步，新建一个断言处理类 Asserts，简化抛出 ApiException 的步骤。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class Asserts {\n    public static void fail(String message) {\n        throw new ApiException(message);\n    }\n\n    public static void fail(IErrorCode errorCode) {\n        throw new ApiException(errorCode);\n    }\n}\n")])])]),n("p",[e._v("第三步，新建一全局异常处理类 GlobalExceptionHandler，对异常信息进行解析，并封装到统一的返回对象 ResultObject 中。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@ControllerAdvice\npublic class GlobalExceptionHandler {\n    @ResponseBody\n    @ExceptionHandler(value = ApiException.class)\n    public ResultObject handle(ApiException e) {\n        if (e.getErrorCode() != null) {\n            return ResultObject.failed(e.getErrorCode());\n        }\n        return ResultObject.failed(e.getMessage());\n    }\n}\n")])])]),n("p",[e._v("全局异常处理类用到了两个注解，@ControllerAdvice 和 @ExceptionHandler。")]),e._v(" "),n("p",[e._v("@ControllerAdvice 是一个特殊的 @Component（可以通过源码看得到），用于标识一个类，这个类中被以下三种注解标识的方法：@ExceptionHandler，@InitBinder，@ModelAttribute，将作用于所有@Controller 类的接口上。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Component\npublic @interface ControllerAdvice {\n}\n")])])]),n("p",[e._v("@ExceptionHandler 注解的作用就是标识统一异常处理，它可以指定要统一处理的异常类型，比如说我们自定义的 ApiException。")]),e._v(" "),n("p",[e._v("第四步，在需要校验的地方通过 Asserts 类抛出异常 ApiException。还拿用户登录这个接口来说明吧。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Controller\n@Api(tags="用户")\n@RequestMapping("/users")\npublic class UsersController {\n    @ApiOperation(value = "登录以后返回token")\n    @RequestMapping(value = "/login", method = RequestMethod.POST)\n    @ResponseBody\n    public ResultObject login(@Validated UsersLoginParam users, BindingResult result) {\n        String token = usersService.login(users.getUserLogin(), users.getUserPass());\n     \n        Map<String, String> tokenMap = new HashMap<>();\n        tokenMap.put("token", token);\n        tokenMap.put("tokenHead", tokenHead);\n        return ResultObject.success(tokenMap);\n    }\n}\n')])])]),n("p",[e._v("该接口需要查询数据库验证密码是否正确，如果密码不正确就抛出校验信息“密码不正确”。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('@Service\npublic class UsersServiceImpl extends ServiceImpl<UsersMapper, Users> implements IUsersService {\n    public String login(String username, String password) {\n        String token = null;\n        //密码需要客户端加密后传递\n        UserDetails userDetails = loadUserByUsername(username);\n        if (!passwordEncoder.matches(password, userDetails.getPassword())) {\n            Asserts.fail("密码不正确");\n         }\n        // 其他代码省略\n        return token;\n    }\n}\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("config\ncontroller\ndto\nmapper\nmodel\nservice impl\nwebapi\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);