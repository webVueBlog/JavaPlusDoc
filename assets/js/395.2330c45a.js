(window.webpackJsonp=window.webpackJsonp||[]).push([[395],{1221:function(e,t,s){"use strict";s.r(t);var i=s(1),a=Object(i.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("点击勘误"),t("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[e._v("issues"),t("OutboundLink")],1),e._v("，哪吒感谢大家的阅读")])]),e._v(" "),t("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),e._v(" "),t("h2",{attrs:{id:"springboot整合redis缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springboot整合redis缓存"}},[e._v("#")]),e._v(" SpringBoot整合Redis缓存")]),e._v(" "),t("p",[e._v("目前用的是 macOS，直接执行 brew install redis 就可以完成安装了。")]),e._v(" "),t("p",[e._v("完成安装后执行 redis-server 就可以启动 Redis 服务了。")]),e._v(" "),t("h2",{attrs:{id:"redis-数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-数据类型"}},[e._v("#")]),e._v(" Redis 数据类型")]),e._v(" "),t("p",[e._v("Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。")]),e._v(" "),t("p",[e._v("1）string")]),e._v(" "),t("p",[e._v("string 是 Redis 最基本的数据类型，一个key对应一个value。")]),e._v(" "),t("p",[e._v("我们可以通过 AnotherRedisDesktopManager 客户端来练习一下基本的 set、get 命令")]),e._v(" "),t("p",[e._v("2）hash")]),e._v(" "),t("p",[e._v("Redis hash 是一个键值对集合，值可以看成是一个 Map。")]),e._v(" "),t("p",[e._v("3）list")]),e._v(" "),t("p",[e._v("list 是一个简单的字符串列表，按照插入顺序排序。")]),e._v(" "),t("p",[e._v("4）set")]),e._v(" "),t("p",[e._v("set 是 string 类型的无序集合，不允许有重复的元素。")]),e._v(" "),t("p",[e._v("5）sorted set")]),e._v(" "),t("p",[e._v("sorted set 是 string 类型的有序集合，不允许有重复的元素。")]),e._v(" "),t("h2",{attrs:{id:"spring-boot-整合-redis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot-整合-redis"}},[e._v("#")]),e._v(" Spring Boot 整合 Redis")]),e._v(" "),t("p",[e._v("第一步，在 pom.xml 文件中添加 Redis 的 starter。")]),e._v(" "),t("p",[e._v("第二步，在 application.yml 文件中添加 Redis 的配置信息")]),e._v(" "),t("p",[e._v("第三步，在测试类中添加代码。")]),e._v(" "),t("p",[e._v("RedisTemplate 和 StringRedisTemplate 都是 Spring Data Redis 提供的模板类，可以对 Redis 进行操作，后者针对键值对都是 String 类型的数据，前者可以是任何类型的对象。")]),e._v(" "),t("p",[e._v("RedisTemplate 和 StringRedisTemplate 除了提供 opsForValue 方法来操作字符串之外，还提供了以下方法：")]),e._v(" "),t("ol",[t("li",[e._v("opsForList：操作 list")]),e._v(" "),t("li",[e._v("opsForSet：操作 set")]),e._v(" "),t("li",[e._v("opsForZSet：操作有序 set")]),e._v(" "),t("li",[e._v("opsForHash：操作 hash")])]),e._v(" "),t("p",[e._v("通过 @Cacheable、@CachePut、@CacheEvict、@EnableCaching 等注解就可以轻松使用 Redis 做缓存了。")]),e._v(" "),t("p",[e._v("1）@EnableCaching，开启缓存功能。")]),e._v(" "),t("p",[e._v("2）@Cacheable，调用方法前，去缓存中找，找到就返回，找不到就执行方法，并将返回值放到缓存中。")]),e._v(" "),t("p",[e._v("3）@CachePut，方法调用前不会去缓存中找，无论如何都会执行方法，执行完将返回值放到缓存中。")]),e._v(" "),t("p",[e._v("4）@CacheEvict，清理缓存中的一个或多个记录。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@EnableCaching\n@Configuration\npublic class RedisConfig extends CachingConfigurerSupport {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n\n        // 通过 Jackson 组件进行序列化\n        RedisSerializer<Object> serializer = redisSerializer();\n\n        // key 和 value\n        // 一般来说， redis-key采用字符串序列化；\n        // redis-value采用json序列化， json的体积小，可读性高，不需要实现serializer接口。\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n        redisTemplate.setValueSerializer(serializer);\n\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());\n        redisTemplate.setHashValueSerializer(serializer);\n\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n\n    @Bean\n    public RedisSerializer<Object> redisSerializer() {\n        //创建JSON序列化器\n        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        // objectMapper.enableDefaultTyping()被弃用\n        objectMapper.activateDefaultTyping(\n                LaissezFaireSubTypeValidator.instance,\n                ObjectMapper.DefaultTyping.NON_FINAL,\n                JsonTypeInfo.As.WRAPPER_ARRAY);\n        serializer.setObjectMapper(objectMapper);\n        return serializer;\n    }\n\n}\n")])])]),t("p",[e._v("第四步，在标签更新接口中添加 @CachePut 注解，也就是说方法执行前不会去缓存中找，但方法执行完会将返回值放入缓存中。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('@Controller\n@Api(tags = "标签")\n@RequestMapping("/postTag")\npublic class PostTagController {\n\n    @Autowired\n    private IPostTagService postTagService;\n    @Autowired\n    private IPostTagRelationService postTagRelationService;\n\n    @RequestMapping(value = "/update", method = RequestMethod.POST)\n    @ResponseBody\n    @ApiOperation("修改标签")\n    @CachePut(value = "codingmore", key = "\'codingmore:postag:\'+#postAddTagParam.postTagId")\n    public ResultObject<String> update(@Valid PostTagParam postAddTagParam) {\n        if (postAddTagParam.getPostTagId() == null) {\n            return ResultObject.failed("标签id不能为空");\n        }\n        PostTag postTag = postTagService.getById(postAddTagParam.getPostTagId());\n        if (postTag == null) {\n            return ResultObject.failed("标签不存在");\n        }\n        QueryWrapper<PostTag> queryWrapper = new QueryWrapper<>();\n        queryWrapper.eq("description", postAddTagParam.getDescription());\n        int count = postTagService.count(queryWrapper);\n        if (count > 0) {\n            return ResultObject.failed("标签名称已存在");\n        }\n        BeanUtils.copyProperties(postAddTagParam, postTag);\n        return ResultObject.success(postTagService.updateById(postTag) ? "修改成功" : "修改失败");\n    }\n}\n')])])]),t("h2",{attrs:{id:"使用-redis-连接池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-redis-连接池"}},[e._v("#")]),e._v(" 使用 Redis 连接池")]),e._v(" "),t("p",[e._v("Redis 是基于内存的数据库，本来是为了提高程序性能的，但如果不使用 Redis 连接池的话，建立连接、断开连接就需要消耗大量的时间。")]),e._v(" "),t("p",[e._v("用了连接池，就可以实现在客户端建立多个连接，需要的时候从连接池拿，用完了再放回去，这样就节省了连接建立、断开的时间。")]),e._v(" "),t("p",[e._v("要使用连接池，我们得先了解 Redis 的客户端，常用的有两种：Jedis 和 Lettuce。")]),e._v(" "),t("ol",[t("li",[e._v("Jedis：Spring Boot 1.5.x 版本时默认的 Redis 客户端，实现上是直接连接 Redis Server，如果在多线程环境下是非线程安全的，这时候要使用连接池为每个 jedis 实例增加物理连接；")]),e._v(" "),t("li",[e._v("Lettuce：Spring Boot 2.x 版本后默认的 Redis 客户端，基于 Netty 实现，连接实例可以在多个线程间并发访问，一个连接实例不够的情况下也可以按需要增加连接实例。")])]),e._v(" "),t("p",[e._v("1）Lettuce")]),e._v(" "),t("p",[e._v("第一步，修改 application-dev.yml，添加 Lettuce 连接池配置（pool 节点）。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("spring:\n    redis:\n        lettuce:\n          pool:\n            max-active: 8 # 连接池最大连接数\n            max-idle: 8 # 连接池最大空闲连接数\n            min-idle: 0 # 连接池最小空闲连接数\n            max-wait: -1ms # 连接池最大阻塞等待时间，负值表示没有限制\n")])])]),t("p",[e._v("第二步，在 pom.xml 文件中添加 commons-pool2 依赖，否则会在启动的时候报 ClassNotFoundException 的错。这是因为 Spring Boot 2.x 里默认没启用连接池。")]),e._v(" "),t("p",[e._v("添加 commons-pool2 依赖")]),e._v(" "),t("p",[e._v("重新启动服务，在 RedisConfig 类的 redisTemplate 方法里对 redisTemplate 打上断点，debug 模式下可以看到连接池的配置信息（redisConnectionFactory→clientConfiguration→poolConfig）。")]),e._v(" "),t("p",[e._v("2）Jedis")]),e._v(" "),t("p",[e._v("第一步，在 pom.xml 文件中添加 Jedis 依赖，去除 Lettuce 默认依赖。")]),e._v(" "),t("p",[e._v("第二步，修改 application-dev.yml，添加 Jedis 连接池配置。")]),e._v(" "),t("p",[e._v("启动服务后，观察 redisTemplate 的 clientConfiguration 节点，可以看到它的值已经变成 DefaultJedisClientConfiguration 对象了。")]),e._v(" "),t("p",[e._v("当然了，也可以不配置 Jedis 客户端的连接池，走默认的连接池配置。因为 Jedis 客户端默认增加了连接池的依赖包，在 pom.xml 文件中点开 Jedis 客户端依赖可以查看到。")]),e._v(" "),t("h2",{attrs:{id:"自由操作-redis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自由操作-redis"}},[e._v("#")]),e._v(" 自由操作 Redis")]),e._v(" "),t("p",[e._v("Spring Cache 虽然提供了操作 Redis 的便捷方法，比如我们前面演示的 @CachePut 注解，但注解提供的操作非常有限，比如说它只能保存返回值到缓存中，而返回值并不一定是我们想要保存的结果。")]),e._v(" "),t("p",[e._v("与其保存这个返回给客户端的 JSON 信息，我们更想保存的是更新后的标签。那该怎么自由地操作 Redis 呢？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public interface RedisService {\n\n    /**\n     * 保存属性\n     */\n    void set(String key, Object value);\n\n    /**\n     * 获取属性\n     */\n    Object get(String key);\n\n    /**\n     * 删除属性\n     */\n    Boolean del(String key);\n\n    ...\n\n\n}\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);