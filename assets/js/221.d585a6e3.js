(window.webpackJsonp=window.webpackJsonp||[]).push([[221],{1014:function(t,a,e){"use strict";e.r(a);var n=e(1),v=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("点击勘误"),a("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[t._v("issues"),a("OutboundLink")],1),t._v("，哪吒感谢大家的阅读")])]),t._v(" "),a("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),t._v(" "),a("h2",{attrs:{id:"不可变对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不可变对象"}},[t._v("#")]),t._v(" 不可变对象")]),t._v(" "),a("p",[t._v("一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。它的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改。")]),t._v(" "),a("p",[t._v("为了保护状态的原子性、可见性、有序性，我们程序员可以说是竭尽所能。其中，synchronized（同步）关键字是最简单最入门的一种解决方案。")]),t._v(" "),a("p",[t._v("假如说类是不可变的，那么对象的状态就也是不可变的。这样的话，每次修改对象的状态，就会产生一个新的对象供不同的线程使用，我们程序员就不必再担心并发问题了。")]),t._v(" "),a("h3",{attrs:{id:"常见的不可变类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的不可变类"}},[t._v("#")]),t._v(" 常见的不可变类")]),t._v(" "),a("p",[t._v("1）常量池的需要")]),t._v(" "),a("p",[t._v("字符串常量池是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串在常量池中不存在，那么就创建一个；假如已经存，就不会再创建了，而是直接引用已经存在的对象。这样做能够减少 JVM 的内存开销，提高效率。")]),t._v(" "),a("p",[t._v("2）hashCode 需要")]),t._v(" "),a("p",[t._v("因为字符串是不可变的，所以在它创建的时候，其 hashCode 就被缓存了，因此非常适合作为哈希值（比如说作为 HashMap 的键），多次调用只返回同一个值，来提高效率。")]),t._v(" "),a("p",[t._v("3）线程安全")]),t._v(" "),a("p",[t._v("就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而 String 是不可变的，就可以在多个线程之间共享，不需要同步处理。")]),t._v(" "),a("p",[t._v("因此，当我们调用 String 类的任何方法（比如说 trim()、substring()、toLowerCase()）时，总会返回一个新的对象，而不影响之前的值。")]),t._v(" "),a("h2",{attrs:{id:"方法重写-override-和方法重载-overload-有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法重写-override-和方法重载-overload-有什么区别"}},[t._v("#")]),t._v(" 方法重写 Override 和方法重载 Overload 有什么区别？")]),t._v(" "),a("p",[t._v("01、方法重载")]),t._v(" "),a("p",[t._v("第一，改变参数的数目")]),t._v(" "),a("p",[t._v("第二，通过改变参数类型，也可以达到方法重载的目的。")]),t._v(" "),a("p",[t._v("02、方法重写")]),t._v(" "),a("p",[t._v("重写的方法必须和父类中的方法有着相同的名字；")]),t._v(" "),a("p",[t._v("重写的方法必须和父类中的方法有着相同的参数；")]),t._v(" "),a("p",[t._v("必须是 is-a 的关系（继承关系）。")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("“首先来说一下方法重载时的注意事项，‘两同一不同’。”")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("“‘两同’：在同一个类，方法名相同。”\n\n“‘一不同’：参数不同。”\n")])])]),a("p",[t._v("“再来说一下方法重写时的注意事项，‘两同一小一大’。”")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("“‘两同’：方法名相同，参数相同。”\n\n“‘一小’：子类方法声明的异常类型要比父类小一些或者相等。”\n\n“‘一大’：子类方法的访问权限应该比父类的更大或者相等。”\n")])])]),a("h2",{attrs:{id:"枚举-enum"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#枚举-enum"}},[t._v("#")]),t._v(" 枚举（enum）")]),t._v(" "),a("p",[t._v("“枚举（enum），是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，继承自 java.lang.Enum。”")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('public enum PlayerType {\n\tTENNIS,\n\tFOOTBALL,\n\tBASKETBALL\n}\n\n\npublic enum PlayerType {\n\tTENNIS("网球"),\n\tFOOTBALL("足球"),\n\tBASKETBALL("篮球");\n\n\tprivate String name;\n\n\tPlayerType(String name) {\n\t\tthis.name = name;\n\t}\n}\n')])])])])}),[],!1,null,null,null);a.default=v.exports}}]);