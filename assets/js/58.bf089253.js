(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{1377:function(e,t,n){"use strict";n.r(t);var a=n(1),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("点击勘误"),t("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[e._v("issues"),t("OutboundLink")],1),e._v("，哪吒感谢大家的阅读")])]),e._v(" "),t("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),e._v(" "),t("h2",{attrs:{id:"获取线程的执行结果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#获取线程的执行结果"}},[e._v("#")]),e._v(" 获取线程的执行结果")]),e._v(" "),t("p",[e._v("创建线程的 3 种方式，一种是直接继承 Thread，一种是实现 Runnable 接口，另外一种是实现 Callable 接口。")]),e._v(" "),t("p",[e._v("前 2 种方式都有一个缺陷：在执行完任务之后无法获取执行结果。")]),e._v(" "),t("p",[e._v("如果需要获取执行结果，就必须通过"),t("strong",[e._v("共享变量或者线程通信")]),e._v("的方式来达到目的，这样使用起来就比较麻烦。")]),e._v(" "),t("p",[e._v("Java 1.5 提供了 "),t("code",[e._v("Callable、Future、FutureTask")]),e._v("，它们可以在任务执行完后得到执行结果，今天我们就来详细的了解一下。")]),e._v(" "),t("h2",{attrs:{id:"无返回值的-runnable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无返回值的-runnable"}},[e._v("#")]),e._v(" 无返回值的 Runnable")]),e._v(" "),t("p",[e._v("由于 Runnable 的 run() 方法的返回值为 void：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public interface Runnable {\n    public abstract void run();\n}\n")])])]),t("p",[e._v("所以在执行完任务之后无法返回任何结果。")]),e._v(" "),t("h2",{attrs:{id:"有返回值的-callable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有返回值的-callable"}},[e._v("#")]),e._v(" 有返回值的 Callable")]),e._v(" "),t("p",[e._v("Callable 位于 java.util.concurrent 包下，也是一个接口，它定义了一个 call() 方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public interface Callable<V> {\n    V call() throws Exception;\n}\n")])])]),t("p",[e._v("可以看到，call() 方法返回的类型是一个 V 类型的泛型。")]),e._v(" "),t("p",[e._v("那怎么使用 Callable 呢？")]),e._v(" "),t("p",[e._v("一般会配合 "),t("code",[e._v("ExecutorService")]),e._v(" 来使用。")]),e._v(" "),t("p",[e._v("ExecutorService 是一个接口，位于 java.util.concurrent 包下，它是 Java 线程池框架的核心接口，用来异步执行任务。它提供了一些关键方法用来进行线程管理。")]),e._v(" "),t("p",[t("img",{attrs:{src:n(735),alt:"img_1.png"}})]),e._v(" "),t("p",[e._v("用到了 "),t("code",[e._v("ExecutorService")]),e._v(" 的 submit 方法。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 创建一个包含5个线程的线程池\nExecutorService executorService = Executors.newFixedThreadPool(5);\n\n// 创建一个Callable任务\nCallable<String> task = new Callable<String>() {\n    public String call() {\n        return "Hello from " + Thread.currentThread().getName();\n    }\n};\n\n// 提交任务到ExecutorService执行，并获取Future对象\nFuture[] futures = new Future[10];\nfor (int i = 0; i < 10; i++) {\n    futures[i] = executorService.submit(task);\n}\n\n// 通过Future对象获取任务的结果\nfor (int i = 0; i < 10; i++) {\n    System.out.println(futures[i].get());\n}\n\n// 关闭ExecutorService，不再接受新的任务，等待所有已提交的任务完成\nexecutorService.shutdown();\n')])])]),t("p",[e._v("我们通过 Executors 工具类来创建一个 ExecutorService，然后向里面提交 Callable 任务，然后通过 Future 来获取执行结果。")]),e._v(" "),t("p",[e._v("为了做对比，我们再来看一下使用 Runnable 的方式：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 创建一个包含5个线程的线程池\nExecutorService executorService = Executors.newFixedThreadPool(5);\n\n// 创建一个Runnable任务\nRunnable task = new Runnable() {\n    public void run() {\n        System.out.println("Hello from " + Thread.currentThread().getName());\n    }\n};\n\n// 提交任务到ExecutorService执行\nfor (int i = 0; i < 10; i++) {\n    executorService.submit(task);\n}\n\n// 关闭ExecutorService，不再接受新的任务，等待所有已提交的任务完成\nexecutorService.shutdown();\n')])])]),t("p",[e._v("可以看到，使用 Runnable 的方式要比 Callable 的方式简单一些，但是 Callable 的方式可以获取执行结果，这是 Runnable 做不到的。")]),e._v(" "),t("h2",{attrs:{id:"异步计算结果-future-接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步计算结果-future-接口"}},[e._v("#")]),e._v(" 异步计算结果 Future 接口")]),e._v(" "),t("p",[e._v("在前面的例子中，我们通过 Future 来获取 Callable 任务的执行结果，那么 Future 是什么呢？")]),e._v(" "),t("p",[e._v("Future 位于 java.util.concurrent 包下，它是一个接口：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public interface Future<V> {\n    boolean cancel(boolean mayInterruptIfRunning);\n    boolean isCancelled();\n    boolean isDone();\n    V get() throws InterruptedException, ExecutionException;\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n")])])]),t("p",[e._v("一共声明了 5 个方法：")]),e._v(" "),t("ol",[t("li",[e._v("cancel() 方法用来取消任务，如果取消任务成功则返回 true，如果取消任务失败则返回 false。参数 mayInterruptIfRunning 表示是否允许取消正在执行却没有执行完毕的任务，如果设置 true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论 mayInterruptIfRunning 为 true 还是 false，此方法肯定返回 false，即如果取消已经完成的任务会返回 false；如果任务正在执行，若 mayInterruptIfRunning 设置为 true，则返回 true，若 mayInterruptIfRunning 设置为 false，则返回 false；如果任务还没有执行，则无论 mayInterruptIfRunning 为 true 还是 false，肯定返回 true。")]),e._v(" "),t("li",[e._v("isCancelled() 方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。")]),e._v(" "),t("li",[e._v("isDone() 方法表示任务是否已经完成，若任务完成，则返回 true；")]),e._v(" "),t("li",[e._v("get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；")]),e._v(" "),t("li",[e._v("get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回 null。")])]),e._v(" "),t("p",[e._v("也就是说 Future 提供了三种功能：")]),e._v(" "),t("ul",[t("li",[e._v("1）判断任务是否完成；")]),e._v(" "),t("li",[e._v("2）能够中断任务；")]),e._v(" "),t("li",[e._v("3）能够获取任务执行结果。")])]),e._v(" "),t("p",[e._v("由于 Future 只是一个接口，如果直接 new 的话，编译器是会有一个 ⚠️ 警告的，它会提醒我们最好使用 FutureTask。")]),e._v(" "),t("p",[t("img",{attrs:{src:n(736),alt:"img_2.png"}})]),e._v(" "),t("p",[e._v("实际上，FutureTask 是 Future 接口的一个唯一实现类，我们在前面的例子中 executorService.submit() 返回的就是 FutureTask，通过 debug 模式可以观察到。")]),e._v(" "),t("p",[t("img",{attrs:{src:n(737),alt:"img_3.png"}})]),e._v(" "),t("h2",{attrs:{id:"异步计算结果-futuretask-实现类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步计算结果-futuretask-实现类"}},[e._v("#")]),e._v(" 异步计算结果 FutureTask 实现类")]),e._v(" "),t("p",[e._v("我们来看一下 FutureTask 的实现：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public class FutureTask<V> implements RunnableFuture<V>\n")])])]),t("p",[e._v("FutureTask 类实现了 RunnableFuture 接口，我们看一下 RunnableFuture 接口的实现：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public interface RunnableFuture<V> extends Runnable, Future<V> {\n    void run();\n}\n")])])]),t("p",[e._v("可以看出 RunnableFuture 继承了 Runnable 接口和 Future 接口，而 FutureTask 实现了 RunnableFuture 接口。所以它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。")]),e._v(" "),t("p",[e._v("FutureTask 提供了 2 个构造器：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public FutureTask(Callable<V> callable) {\n}\npublic FutureTask(Runnable runnable, V result) {\n}\n")])])]),t("p",[e._v("当需要异步执行一个计算并在稍后的某个时间点获取其结果时，就可以使用 FutureTask。来个例子")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 创建一个固定大小的线程池\nExecutorService executorService = Executors.newFixedThreadPool(3);\n\n// 创建一系列 Callable\nCallable<Integer>[] tasks = new Callable[5];\nfor (int i = 0; i < tasks.length; i++) {\n    final int index = i;\n    tasks[i] = new Callable<Integer>() {\n        @Override\n        public Integer call() throws Exception {\n            TimeUnit.SECONDS.sleep(index + 1);\n            return (index + 1) * 100;\n        }\n    };\n}\n\n// 将 Callable 包装为 FutureTask，并提交到线程池\nFutureTask<Integer>[] futureTasks = new FutureTask[tasks.length];\nfor (int i = 0; i < tasks.length; i++) {\n    futureTasks[i] = new FutureTask<>(tasks[i]);\n    executorService.submit(futureTasks[i]);\n}\n\n// 获取任务结果\nfor (int i = 0; i < futureTasks.length; i++) {\n    System.out.println("Result of task" + (i + 1) + ": " + futureTasks[i].get());\n}\n\n// 关闭线程池\nexecutorService.shutdown();\n')])])])])}),[],!1,null,null,null);t.default=r.exports},735:function(e,t,n){e.exports=n.p+"assets/img/img_1.6f408ff1.png"},736:function(e,t,n){e.exports=n.p+"assets/img/img_2.a5b4fc19.png"},737:function(e,t,n){e.exports=n.p+"assets/img/img_3.6713f523.png"}}]);