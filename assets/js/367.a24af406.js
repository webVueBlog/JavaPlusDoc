(window.webpackJsonp=window.webpackJsonp||[]).push([[367],{1184:function(t,v,e){"use strict";e.r(v);var _=e(1),i=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("blockquote",[v("p",[t._v("点击勘误"),v("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[t._v("issues"),v("OutboundLink")],1),t._v("，哪吒感谢大家的阅读")])]),t._v(" "),v("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),t._v(" "),v("h2",{attrs:{id:"物联网iot"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#物联网iot"}},[t._v("#")]),t._v(" 物联网iot")]),t._v(" "),v("p",[t._v("类 AppListener 是一个 "),v("code",[t._v("Spring Boot")]),t._v(" 应用的监听器，主要用于在应用程序启动并准备就绪后执行一些初始化操作。它实现了 "),v("code",[t._v("ApplicationListener<ApplicationReadyEvent>")]),t._v(" 接口，监听 Spring Boot 应用的启动事件，并在应用完全启动后执行逻辑。")]),t._v(" "),v("h3",{attrs:{id:"作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用：")]),t._v(" "),v("p",[t._v("AppListener 监听应用启动事件（"),v("code",[t._v("ApplicationReadyEvent")]),t._v("），并在应用启动完成后执行以下操作：")]),t._v(" "),v("ul",[v("li",[t._v("启动一个 TCP 服务端 JT808 进行监听。")]),t._v(" "),v("li",[t._v("启动一个独立线程，定期同步实时信息到缓存。")])]),t._v(" "),v("h3",{attrs:{id:"过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#过程"}},[t._v("#")]),t._v(" 过程：")]),t._v(" "),v("p",[t._v("初始化和依赖注入：")]),t._v(" "),v("ul",[v("li",[t._v("使用 @Autowired 注解注入了 类的实例，这些组件在应用启动后将被用于执行具体任务。")]),t._v(" "),v("li",[t._v("日志对象 logger 用于记录应用运行时的信息，使用了 SLF4J 和 Logback 来输出日志。")])]),t._v(" "),v("p",[t._v("监听 "),v("code",[t._v("ApplicationReadyEvent")]),t._v("：")]),t._v(" "),v("p",[t._v("onApplicationEvent 方法在应用启动完成并准备就绪后被调用。")]),t._v(" "),v("p",[t._v("启动 "),v("code",[t._v("TCP")]),t._v(" 服务端：")]),t._v(" "),v("p",[t._v("在 "),v("code",[t._v("onApplicationEvent")]),t._v(" 方法中，首先通过创建一个新的线程 Thread 来启动 TCP 服务端监听 。")]),t._v(" "),v("p",[t._v("同步实时信息到缓存：")]),t._v(" "),v("p",[t._v("另一个线程 用于定期将实时信息同步到缓存。该线程会在 while(true) 无限循环中运行，不断调用  方法同步数据。\n每次同步后，记录同步操作的耗时，并休眠 毫秒再进行下一次同步。")]),t._v(" "),v("p",[t._v("异常处理：")]),t._v(" "),v("ul",[v("li",[t._v("在整个过程中，异常被捕获并打印日志（logger.error），如果有任何异常，程序会尝试输出错误信息，并在 "),v("code",[t._v("onApplicationEvent")]),t._v(" 方法的最外层捕获异常来确保应用能捕获到初始化过程中的错误。")]),t._v(" "),v("li",[t._v("如果捕获到异常，应用会退出（调用 "),v("code",[t._v("System.exit(0)")]),t._v("）。")])]),t._v(" "),v("p",[t._v("总结：")]),t._v(" "),v("p",[t._v("AppListener 的作用是当 Spring Boot 应用启动完成后，自动启动一些后台服务，比如：")]),t._v(" "),v("ul",[v("li",[t._v("启动 TCP 服务端监听客户端连接。")]),t._v(" "),v("li",[t._v("定期同步实时信息到缓存中。 这些任务是应用启动后需要进行的初始化操作。")])])])}),[],!1,null,null,null);v.default=i.exports}}]);