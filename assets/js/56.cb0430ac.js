(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{1268:function(t,s,n){"use strict";n.r(s);var r=n(1),a=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("blockquote",[s("p",[t._v("点击勘误"),s("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[t._v("issues"),s("OutboundLink")],1),t._v("，哪吒感谢大家的阅读")])]),t._v(" "),s("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),t._v(" "),s("h2",{attrs:{id:"io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#io模型"}},[t._v("#")]),t._v(" IO模型")]),t._v(" "),s("p",[t._v("阻塞 I/O（Blocking I/O）：在这种模型中，I/O 操作是阻塞的，即执行 I/O 操作时，线程会被阻塞，直到操作完成。在阻塞 I/O 模型中，每个连接都需要一个线程来处理。因此，对于大量并发连接的场景，阻塞 I/O 模型的性能较差。")]),t._v(" "),s("p",[s("img",{attrs:{src:n(630),alt:"img_4.png"}})]),t._v(" "),s("p",[t._v("非阻塞 I/O（Non-blocking I/O）：在这种模型中，I/O 操作不会阻塞线程。当数据尚未准备好时，I/O 调用会立即返回。线程可以继续执行其他任务，然后在适当的时候再次尝试执行 I/O 操作。非阻塞 I/O 模型允许单个线程同时处理多个连接，但可能需要在应用程序级别进行复杂的调度和管理。")]),t._v(" "),s("p",[s("img",{attrs:{src:n(631),alt:"img_5.png"}})]),t._v(" "),s("h2",{attrs:{id:"内核空间和用户空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内核空间和用户空间"}},[t._v("#")]),t._v(" 内核空间和用户空间")]),t._v(" "),s("p",[s("img",{attrs:{src:n(632),alt:"img_6.png"}})])])}),[],!1,null,null,null);s.default=a.exports},630:function(t,s,n){t.exports=n.p+"assets/img/img_4.1481f78c.png"},631:function(t,s,n){t.exports=n.p+"assets/img/img_5.5232338b.png"},632:function(t,s,n){t.exports=n.p+"assets/img/img_6.c88571a4.png"}}]);