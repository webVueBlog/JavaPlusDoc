(window.webpackJsonp=window.webpackJsonp||[]).push([[434],{1267:function(v,a,_){"use strict";_.r(a);var t=_(1),O=Object(t.a)({},(function(){var v=this,a=v._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("blockquote",[a("p",[v._v("点击勘误"),a("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[v._v("issues"),a("OutboundLink")],1),v._v("，哪吒感谢大家的阅读")])]),v._v(" "),a("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),v._v(" "),a("h2",{attrs:{id:"nio和bio和aio的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nio和bio和aio的区别"}},[v._v("#")]),v._v(" NIO和BIO和AIO的区别")]),v._v(" "),a("h3",{attrs:{id:"java-io-与-bio、nio"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-io-与-bio、nio"}},[v._v("#")]),v._v(" Java IO 与 BIO、NIO")]),v._v(" "),a("p",[v._v("IO，常写作 I/O，是 Input/Output 的简称，即输入/输出。通常指数据在内部存储器（内存）和外部存储器（硬盘、优盘等）或其他周边设备之间的输入和输出。")]),v._v(" "),a("p",[v._v("输入/输出是信息处理系统（例如计算机）与外部世界（可能是人类或另一信息处理系统）之间的通信。")]),v._v(" "),a("p",[v._v("输入是系统接收的信号或数据，输出则是从其发送的信号或数据。")]),v._v(" "),a("p",[v._v("在 Java 中，提供了一系列 API，可以供开发者来读写外部数据或文件。我们称这些 API 为 Java IO。")]),v._v(" "),a("p",[v._v("IO 是 Java 中比较重要，且比较难的知识点，主要是因为随着 Java 的发展，目前有三种 IO 共存。分别是 BIO、NIO 和 AIO。")]),v._v(" "),a("p",[v._v("BIO 全称 Block-IO 是一种同步且阻塞的通信模式。是一个比较传统的通信方式，模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速。")]),v._v(" "),a("p",[v._v("Java NIO，全程 Non-Block IO ，是 Java SE 1.4 版以后，针对网络传输效能优化的新功能。是一种非阻塞同步的通信模式。")]),v._v(" "),a("p",[v._v("NIO 与原来的 I/O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。")]),v._v(" "),a("p",[v._v("面向流的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。")]),v._v(" "),a("p",[v._v("面向块的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。")]),v._v(" "),a("p",[v._v("Java AIO，全称 Asynchronous IO，是异步非阻塞的 IO。是一种非阻塞异步的通信模式。")]),v._v(" "),a("p",[v._v("在 NIO 的基础上引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。")]),v._v(" "),a("h2",{attrs:{id:"三种-io-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三种-io-的区别"}},[v._v("#")]),v._v(" 三种 IO 的区别")]),v._v(" "),a("p",[v._v("首先，我们站在宏观的角度，重新画一下重点：")]),v._v(" "),a("p",[v._v("BIO （Blocking I/O）：同步阻塞 I/O 模式。")]),v._v(" "),a("p",[v._v("NIO （New I/O）：同步非阻塞模式。")]),v._v(" "),a("p",[v._v("AIO （Asynchronous I/O）：异步非阻塞 I/O 模型。")]),v._v(" "),a("p",[v._v("同步阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。")]),v._v(" "),a("p",[v._v("同步非阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是回到客厅看电视，然后每隔几分钟到厨房看一下水有没有烧开。")]),v._v(" "),a("p",[v._v("异步非阻塞 I/O 模型：这种模式下，我们的工作模式是先来到厨房，开始烧水，我们不一直坐在水壶前面等，也不隔一段时间去看一下，而是在客厅看电视，水壶上面有个开关，水烧开之后他会通知我。")]),v._v(" "),a("p",[v._v("阻塞 VS 非阻塞：人是否坐在水壶前面一直等。")]),v._v(" "),a("p",[v._v("同步 VS 异步：水壶是不是在水烧开之后主动通知人。")]),v._v(" "),a("h2",{attrs:{id:"适用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适用场景"}},[v._v("#")]),v._v(" 适用场景")]),v._v(" "),a("p",[v._v("BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。")]),v._v(" "),a("p",[v._v("NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。")]),v._v(" "),a("p",[v._v("AIO 方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。")]),v._v(" "),a("h3",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[v._v("#")]),v._v(" 小结")]),v._v(" "),a("p",[v._v("BIO（Blocking I/O）：采用阻塞式 I/O 模型，线程在执行 I/O 操作时被阻塞，无法处理其他任务，适用于连接数较少且稳定的场景。")]),v._v(" "),a("p",[v._v("NIO（New I/O 或 Non-blocking I/O）：使用非阻塞 I/O 模型，线程在等待 I/O 时可执行其他任务，通过 Selector 监控多个 Channel 上的事件，提高性能和可伸缩性，适用于高并发场景。")]),v._v(" "),a("p",[v._v("AIO（Asynchronous I/O）：采用异步 I/O 模型，线程发起 I/O 请求后立即返回，当 I/O 操作完成时通过回调函数通知线程，进一步提高了并发处理能力，适用于高吞吐量场景。")])])}),[],!1,null,null,null);a.default=O.exports}}]);