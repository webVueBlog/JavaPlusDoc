(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{1382:function(t,a,e){"use strict";e.r(a);var r=e(1),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("点击勘误"),a("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[t._v("issues"),a("OutboundLink")],1),t._v("，哪吒感谢大家的阅读")])]),t._v(" "),a("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),t._v(" "),a("h2",{attrs:{id:"java线程的6种状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java线程的6种状态"}},[t._v("#")]),t._v(" Java线程的6种状态")]),t._v(" "),a("p",[t._v("在操作系统中，线程被视为轻量级的进程，所以线程状态其实和进程状态是一致的。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(738),alt:"img_4.png"}})]),t._v(" "),a("p",[t._v("操作系统的线程主要有以下三个状态：")]),t._v(" "),a("ol",[a("li",[t._v("就绪状态(ready)：线程正在等待使用 CPU，经调度程序调用之后进入 running 状态。")]),t._v(" "),a("li",[t._v("执行状态(running)：线程正在使用 CPU。")]),t._v(" "),a("li",[t._v("等待状态(waiting): 线程经过等待事件的调用或者正在等待其他资源（如 I/O）。")])]),t._v(" "),a("p",[t._v("然后我们来看 Java 线程的 6 个状态：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// Thread.State 源码\npublic enum State {\n    NEW,\n    RUNNABLE,\n    BLOCKED,\n    WAITING,\n    TIMED_WAITING,\n    TERMINATED;\n}\n")])])]),a("h2",{attrs:{id:"new"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new"}},[t._v("#")]),t._v(" NEW")]),t._v(" "),a("p",[t._v("处于 NEW 状态的线程此时尚未启动。这里的尚未启动指的是还没调用 Thread 实例的start()方法。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("private void testStateNew() {\n    Thread thread = new Thread(() -> {});\n    System.out.println(thread.getState()); // 输出 NEW\n}\n")])])]),a("p",[t._v("从上面可以看出，只是创建了线程而并没有调用 start 方法，此时线程处于 NEW 状态。")]),t._v(" "),a("h2",{attrs:{id:"关于-start-的两个引申问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于-start-的两个引申问题"}},[t._v("#")]),t._v(" 关于 start 的两个引申问题")]),t._v(" "),a("ol",[a("li",[t._v("反复调用同一个线程的 start 方法是否可行？")]),t._v(" "),a("li",[t._v("假如一个线程执行完毕（此时处于 TERMINATED 状态），再次调用这个线程的 start 方法是否可行？")])]),t._v(" "),a("p",[t._v("要分析这两个问题，我们先来看看start()的源码：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 使用synchronized关键字保证这个方法是线程安全的\npublic synchronized void start() {\n    // threadStatus != 0 表示这个线程已经被启动过或已经结束了\n    // 如果试图再次启动这个线程，就会抛出IllegalThreadStateException异常\n    if (threadStatus != 0)\n        throw new IllegalThreadStateException();\n\n    // 将这个线程添加到当前线程的线程组中\n    group.add(this);\n\n    // 声明一个变量，用于记录线程是否启动成功\n    boolean started = false;\n    try {\n        // 使用native方法启动这个线程\n        start0();\n        // 如果没有抛出异常，那么started被设为true，表示线程启动成功\n        started = true;\n    } finally {\n        // 在finally语句块中，无论try语句块中的代码是否抛出异常，都会执行\n        try {\n            // 如果线程没有启动成功，就从线程组中移除这个线程\n            if (!started) {\n                group.threadStartFailed(this);\n            }\n        } catch (Throwable ignore) {\n            // 如果在移除线程的过程中发生了异常，我们选择忽略这个异常\n        }\n    }\n}\n")])])]),a("h2",{attrs:{id:"线程状态的转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程状态的转换"}},[t._v("#")]),t._v(" 线程状态的转换")]),t._v(" "),a("p",[t._v("根据上面关于线程状态的介绍我们可以得到下面的线程状态转换图：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(739),alt:"img_5.png"}})]),t._v(" "),a("h2",{attrs:{id:"线程中断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程中断"}},[t._v("#")]),t._v(" 线程中断")]),t._v(" "),a("p",[t._v("在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。目前在 Java 里还没有安全方法来直接停止线程，但是 Java 提供了线程中断机制来处理需要中断线程的情况。")]),t._v(" "),a("p",[t._v("线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。")]),t._v(" "),a("p",[t._v("简单介绍下 Thread 类里提供的关于线程中断的几个方法：")]),t._v(" "),a("ul",[a("li",[t._v("Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为 true（默认是 flase）；")]),t._v(" "),a("li",[t._v("Thread.isInterrupted()：测试当前线程是否被中断。")]),t._v(" "),a("li",[t._v("Thread.interrupted()：检测当前线程是否被中断，与 isInterrupted() 方法不同的是，这个方法如果发现当前线程被中断，会清除线程的中断状态。")])]),t._v(" "),a("p",[t._v("在线程中断机制里，当其他线程通知需要被中断的线程后，线程中断的状态被设置为 true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己决定，可以在合适的时机中断请求，也可以完全不处理继续执行下去。")]),t._v(" "),a("h2",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("p",[t._v("本文详细解析了 Java 线程的 6 种状态 — 新建、运行、阻塞、等待、定时等待和终止，以及这些状态之间的切换过程。")])])}),[],!1,null,null,null);a.default=s.exports},738:function(t,a,e){t.exports=e.p+"assets/img/img_4.d9c7fab2.png"},739:function(t,a,e){t.exports=e.p+"assets/img/img_5.62ee7e4d.png"}}]);