(window.webpackJsonp=window.webpackJsonp||[]).push([[211],{1005:function(a,r,o){"use strict";o.r(r);var t=o(1),e=Object(t.a)({},(function(){var a=this,r=a._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("blockquote",[r("p",[a._v("点击勘误"),r("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[a._v("issues"),r("OutboundLink")],1),a._v("，哪吒感谢大家的阅读")])]),a._v(" "),r("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),a._v(" "),r("h2",{attrs:{id:"comparable和comparator"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#comparable和comparator"}},[a._v("#")]),a._v(" Comparable和Comparator")]),a._v(" "),r("p",[a._v("Comparable 和 Comparator 是 Java 的两个接口，从名字上我们就能够读出来它们俩的相似性：以某种方式来比较两个对象。")]),a._v(" "),r("p",[a._v("如果一个类实现了 Comparable 接口（只需要干一件事，重写 compareTo() 方法），就可以按照自己制定的规则将由它创建的对象进行比较。")]),a._v(" "),r("p",[a._v("Comparator 接口的定义相比较于 Comparable 就复杂的多了，不过，核心的方法只有两个")]),a._v(" "),r("p",[a._v("第一个方法 compare(T o1, T o2) 的返回值可能为负数，零或者正数，代表的意思是第一个对象小于、等于或者大于第二个对象。")]),a._v(" "),r("p",[a._v("第二个方法 equals(Object obj) 需要传入一个 Object 作为参数，并判断该 Object 是否和 Comparator 保持一致。")]),a._v(" "),r("h2",{attrs:{id:"comparable-和-comparator-两者之间的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#comparable-和-comparator-两者之间的区别"}},[a._v("#")]),a._v(" Comparable 和 Comparator 两者之间的区别：")]),a._v(" "),r("ol",[r("li",[a._v("一个类实现了 Comparable 接口，意味着该类的对象可以直接进行比较（排序），但比较（排序）的方式只有一种，很单一。")]),a._v(" "),r("li",[a._v("一个类如果想要保持原样，又需要进行不同方式的比较（排序），就可以定制比较器（实现 Comparator 接口）。")]),a._v(" "),r("li",[a._v("Comparable 接口在 java.lang 包下，而 Comparator 接口在 java.util 包下，算不上是亲兄弟，但可以称得上是表（堂）兄弟。")])]),a._v(" "),r("p",[a._v("举个不恰当的例子。我想从洛阳出发去北京看长城，体验一下好汉的感觉，要么坐飞机，要么坐高铁；但如果是孙悟空的话，翻个筋斗就到了。我和孙悟空之间有什么区别呢？")]),a._v(" "),r("p",[a._v("孙悟空自己实现了 Comparable 接口（他那年代也没有飞机和高铁，没得选），而我可以借助 Comparator 接口（现代化的交通工具）。")])])}),[],!1,null,null,null);r.default=e.exports}}]);