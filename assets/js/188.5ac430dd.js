(window.webpackJsonp=window.webpackJsonp||[]).push([[188],{981:function(t,n,s){"use strict";s.r(n);var v=s(1),a=Object(v.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("blockquote",[n("p",[t._v("点击勘误"),n("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[t._v("issues"),n("OutboundLink")],1),t._v("，哪吒感谢大家的阅读")])]),t._v(" "),n("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),t._v(" "),n("h2",{attrs:{id:"线程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[t._v("#")]),t._v(" 线程")]),t._v(" "),n("p",[t._v("线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。\nHotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓\n冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。\nJava 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可\n用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。")]),t._v(" "),n("p",[t._v("Hotspot JVM 后台运行的系统线程主要有下面几个：\n虚拟机线程\n（VM thread）")]),t._v(" "),n("p",[t._v("这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当\n堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-theworld 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。")]),t._v(" "),n("p",[t._v("周期性任务线程")]),t._v(" "),n("p",[t._v("这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。")]),t._v(" "),n("p",[t._v("GC 线程")]),t._v(" "),n("p",[t._v("这些线程支持 JVM 中不同的垃圾回收活动。")]),t._v(" "),n("p",[t._v("编译器线程")]),t._v(" "),n("p",[t._v("这些线程在运行时将字节码动态编译成本地平台相关的机器码。")]),t._v(" "),n("p",[t._v("信号分发线程")]),t._v(" "),n("p",[t._v("这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。")])])}),[],!1,null,null,null);n.default=a.exports}}]);