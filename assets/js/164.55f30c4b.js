(window.webpackJsonp=window.webpackJsonp||[]).push([[164],{959:function(t,e,s){"use strict";s.r(e);var n=s(1),a=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"redis底层数据结构原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis底层数据结构原理"}},[t._v("#")]),t._v(" Redis底层数据结构原理")]),t._v(" "),e("h2",{attrs:{id:"概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),e("p",[t._v("Redis是一个高性能的键值存储数据库，其卓越的性能很大程度上得益于其精心设计的底层数据结构。本文深入分析Redis的核心数据结构实现原理，包括SDS、链表、字典、跳跃表、整数集合、压缩列表等。")]),t._v(" "),e("h2",{attrs:{id:"redis对象系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis对象系统"}},[t._v("#")]),t._v(" Redis对象系统")]),t._v(" "),e("h3",{attrs:{id:"对象类型与编码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象类型与编码"}},[t._v("#")]),t._v(" 对象类型与编码")]),t._v(" "),e("p",[t._v("Redis使用对象来表示数据库中的键和值，每个对象都由一个redisObject结构表示：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("typedef struct redisObject {\n    unsigned type:4;        // 类型\n    unsigned encoding:4;    // 编码\n    unsigned lru:24;        // LRU时间\n    int refcount;          // 引用计数\n    void *ptr;             // 指向底层实现数据结构的指针\n} robj;\n")])])]),e("p",[e("strong",[t._v("五种对象类型：")])]),t._v(" "),e("ul",[e("li",[t._v("REDIS_STRING（字符串）")]),t._v(" "),e("li",[t._v("REDIS_LIST（列表）")]),t._v(" "),e("li",[t._v("REDIS_HASH（哈希）")]),t._v(" "),e("li",[t._v("REDIS_SET（集合）")]),t._v(" "),e("li",[t._v("REDIS_ZSET（有序集合）")])]),t._v(" "),e("h2",{attrs:{id:"简单动态字符串-sds"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简单动态字符串-sds"}},[t._v("#")]),t._v(" 简单动态字符串（SDS）")]),t._v(" "),e("h3",{attrs:{id:"sds结构定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sds结构定义"}},[t._v("#")]),t._v(" SDS结构定义")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("struct sdshdr {\n    unsigned int len;       // 记录buf数组中已使用字节的数量\n    unsigned int free;      // 记录buf数组中未使用字节的数量\n    char buf[];            // 字节数组，用于保存字符串\n};\n")])])]),e("h3",{attrs:{id:"sds优势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sds优势"}},[t._v("#")]),t._v(" SDS优势")]),t._v(" "),e("p",[e("strong",[t._v("1. 常数复杂度获取字符串长度")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// C字符串获取长度：O(N)\nsize_t strlen(const char *s);\n\n// SDS获取长度：O(1)\nsize_t sdslen(const sds s) {\n    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));\n    return sh->len;\n}\n")])])]),e("p",[e("strong",[t._v("2. 杜绝缓冲区溢出")])]),t._v(" "),e("ul",[e("li",[t._v("SDS API会自动检查空间是否足够")]),t._v(" "),e("li",[t._v("不足时自动扩展空间")])]),t._v(" "),e("p",[e("strong",[t._v("3. 减少修改字符串时的内存重分配次数")])]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("空间预分配")]),t._v("：扩展SDS时，不仅分配必须空间，还分配额外未使用空间")]),t._v(" "),e("li",[e("strong",[t._v("惰性空间释放")]),t._v("：缩短SDS时，不立即释放多出的字节")])]),t._v(" "),e("p",[e("strong",[t._v("4. 二进制安全")])]),t._v(" "),e("ul",[e("li",[t._v("使用len属性判断字符串结束")]),t._v(" "),e("li",[t._v("可以保存任意格式的二进制数据")])]),t._v(" "),e("h3",{attrs:{id:"sds空间分配策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sds空间分配策略"}},[t._v("#")]),t._v(" SDS空间分配策略")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("sds sdsMakeRoomFor(sds s, size_t addlen) {\n    struct sdshdr *sh, *newsh;\n    size_t free = sdsavail(s);\n    size_t len, newlen;\n    \n    if (free >= addlen) return s;\n    \n    len = sdslen(s);\n    sh = (void*) (s-(sizeof(struct sdshdr)));\n    newlen = (len+addlen);\n    \n    // 空间预分配策略\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;  // 小于1MB时，分配2倍空间\n    else\n        newlen += SDS_MAX_PREALLOC;  // 大于1MB时，额外分配1MB\n    \n    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);\n    newsh->free = newlen - len;\n    return newsh->buf;\n}\n")])])]),e("h2",{attrs:{id:"链表-linkedlist"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#链表-linkedlist"}},[t._v("#")]),t._v(" 链表（LinkedList）")]),t._v(" "),e("h3",{attrs:{id:"链表节点结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#链表节点结构"}},[t._v("#")]),t._v(" 链表节点结构")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("typedef struct listNode {\n    struct listNode *prev;  // 前置节点\n    struct listNode *next;  // 后置节点\n    void *value;           // 节点的值\n} listNode;\n\ntypedef struct list {\n    listNode *head;        // 表头节点\n    listNode *tail;        // 表尾节点\n    void *(*dup)(void *ptr);     // 节点值复制函数\n    void (*free)(void *ptr);     // 节点值释放函数\n    int (*match)(void *ptr, void *key);  // 节点值对比函数\n    unsigned long len;     // 链表所包含的节点数量\n} list;\n")])])]),e("h3",{attrs:{id:"链表特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#链表特性"}},[t._v("#")]),t._v(" 链表特性")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("双端")]),t._v("：获取前置和后置节点的复杂度都是O(1)")]),t._v(" "),e("li",[e("strong",[t._v("无环")]),t._v("：表头节点的prev指针和表尾节点的next指针都指向NULL")]),t._v(" "),e("li",[e("strong",[t._v("带表头指针和表尾指针")]),t._v("：获取表头和表尾节点的复杂度为O(1)")]),t._v(" "),e("li",[e("strong",[t._v("带链表长度计数器")]),t._v("：获取链表长度的复杂度为O(1)")]),t._v(" "),e("li",[e("strong",[t._v("多态")]),t._v("：使用void*指针保存节点值，可以保存各种不同类型的值")])]),t._v(" "),e("h2",{attrs:{id:"字典-dictionary"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字典-dictionary"}},[t._v("#")]),t._v(" 字典（Dictionary）")]),t._v(" "),e("h3",{attrs:{id:"哈希表结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#哈希表结构"}},[t._v("#")]),t._v(" 哈希表结构")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("typedef struct dictht {\n    dictEntry **table;     // 哈希表数组\n    unsigned long size;    // 哈希表大小\n    unsigned long sizemask; // 哈希表大小掩码，用于计算索引值\n    unsigned long used;    // 该哈希表已有节点的数量\n} dictht;\n\ntypedef struct dictEntry {\n    void *key;            // 键\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;                  // 值\n    struct dictEntry *next; // 指向下个哈希表节点，形成链表\n} dictEntry;\n\ntypedef struct dict {\n    dictType *type;       // 类型特定函数\n    void *privdata;       // 私有数据\n    dictht ht[2];         // 哈希表\n    long rehashidx;       // rehash索引，当rehash不在进行时，值为-1\n    int iterators;        // 目前正在运行的安全迭代器的数量\n} dict;\n")])])]),e("h3",{attrs:{id:"哈希算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#哈希算法"}},[t._v("#")]),t._v(" 哈希算法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 使用字典设置的哈希函数，计算键key的哈希值\nhash = dict->type->hashFunction(key);\n\n// 使用哈希表的sizemask属性和哈希值，计算出索引值\nindex = hash & dict->ht[x].sizemask;\n")])])]),e("h3",{attrs:{id:"解决键冲突"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决键冲突"}},[t._v("#")]),t._v(" 解决键冲突")]),t._v(" "),e("p",[t._v("Redis使用"),e("strong",[t._v("链地址法")]),t._v("解决键冲突：")]),t._v(" "),e("ul",[e("li",[t._v("每个哈希表节点都有一个next指针")]),t._v(" "),e("li",[t._v("多个哈希表节点可以用next指针构成一个单向链表")]),t._v(" "),e("li",[t._v("新节点总是添加到链表的表头位置（O(1)复杂度）")])]),t._v(" "),e("h3",{attrs:{id:"rehash过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rehash过程"}},[t._v("#")]),t._v(" rehash过程")]),t._v(" "),e("p",[e("strong",[t._v("触发条件：")])]),t._v(" "),e("ul",[e("li",[t._v("负载因子 = ht[0].used / ht[0].size")]),t._v(" "),e("li",[t._v("扩展：负载因子 >= 1（无BGSAVE/BGREWRITEAOF时）或 >= 5")]),t._v(" "),e("li",[t._v("收缩：负载因子 < 0.1")])]),t._v(" "),e("p",[e("strong",[t._v("渐进式rehash步骤：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int dictRehash(dict *d, int n) {\n    int empty_visits = n * 10; // 最大空桶访问数\n    \n    if (!dictIsRehashing(d)) return 0;\n    \n    while(n-- && d->ht[0].used != 0) {\n        dictEntry *de, *nextde;\n        \n        // 跳过空桶\n        while(d->ht[0].table[d->rehashidx] == NULL) {\n            d->rehashidx++;\n            if (--empty_visits == 0) return 1;\n        }\n        \n        de = d->ht[0].table[d->rehashidx];\n        // 将链表中的所有节点迁移到ht[1]\n        while(de) {\n            uint64_t h;\n            nextde = de->next;\n            h = dictHashKey(d, de->key) & d->ht[1].sizemask;\n            de->next = d->ht[1].table[h];\n            d->ht[1].table[h] = de;\n            d->ht[0].used--;\n            d->ht[1].used++;\n            de = nextde;\n        }\n        d->ht[0].table[d->rehashidx] = NULL;\n        d->rehashidx++;\n    }\n    \n    // 检查是否完成rehash\n    if (d->ht[0].used == 0) {\n        zfree(d->ht[0].table);\n        d->ht[0] = d->ht[1];\n        _dictReset(&d->ht[1]);\n        d->rehashidx = -1;\n        return 0;\n    }\n    return 1;\n}\n")])])]),e("h2",{attrs:{id:"跳跃表-skip-list"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#跳跃表-skip-list"}},[t._v("#")]),t._v(" 跳跃表（Skip List）")]),t._v(" "),e("h3",{attrs:{id:"跳跃表结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#跳跃表结构"}},[t._v("#")]),t._v(" 跳跃表结构")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("typedef struct zskiplistNode {\n    sds ele;                           // 成员对象\n    double score;                      // 分值\n    struct zskiplistNode *backward;    // 后退指针\n    struct zskiplistLevel {\n        struct zskiplistNode *forward; // 前进指针\n        unsigned long span;           // 跨度\n    } level[];                        // 层\n} zskiplistNode;\n\ntypedef struct zskiplist {\n    struct zskiplistNode *header, *tail; // 表头节点和表尾节点\n    unsigned long length;                // 表中节点的数量\n    int level;                          // 表中层数最大的节点的层数\n} zskiplist;\n")])])]),e("h3",{attrs:{id:"跳跃表特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#跳跃表特性"}},[t._v("#")]),t._v(" 跳跃表特性")]),t._v(" "),e("p",[e("strong",[t._v("1. 层级结构")])]),t._v(" "),e("ul",[e("li",[t._v("每个节点包含多个层")]),t._v(" "),e("li",[t._v("每层包含前进指针和跨度")]),t._v(" "),e("li",[t._v("层数随机生成（1-32层）")])]),t._v(" "),e("p",[e("strong",[t._v("2. 查找过程")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("zskiplistNode *zslSearch(zskiplist *zsl, double score, sds ele) {\n    zskiplistNode *x;\n    int i;\n    \n    x = zsl->header;\n    // 从最高层开始查找\n    for (i = zsl->level-1; i >= 0; i--) {\n        while (x->level[i].forward &&\n               (x->level[i].forward->score < score ||\n                (x->level[i].forward->score == score &&\n                 sdscmp(x->level[i].forward->ele, ele) < 0)))\n        {\n            x = x->level[i].forward;\n        }\n    }\n    \n    x = x->level[0].forward;\n    if (x && score == x->score && sdscmp(x->ele, ele) == 0) {\n        return x;\n    }\n    return NULL;\n}\n")])])]),e("p",[e("strong",[t._v("3. 层数生成算法")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int zslRandomLevel(void) {\n    int level = 1;\n    while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))\n        level += 1;\n    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;\n}\n")])])]),e("h2",{attrs:{id:"整数集合-intset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#整数集合-intset"}},[t._v("#")]),t._v(" 整数集合（IntSet）")]),t._v(" "),e("h3",{attrs:{id:"整数集合结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#整数集合结构"}},[t._v("#")]),t._v(" 整数集合结构")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("typedef struct intset {\n    uint32_t encoding; // 编码方式\n    uint32_t length;   // 集合包含的元素数量\n    int8_t contents[]; // 保存元素的数组\n} intset;\n")])])]),e("h3",{attrs:{id:"编码类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编码类型"}},[t._v("#")]),t._v(" 编码类型")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("INTSET_ENC_INT16")]),t._v("：int16_t类型的整数值（-32768 ~ 32767）")]),t._v(" "),e("li",[e("strong",[t._v("INTSET_ENC_INT32")]),t._v("：int32_t类型的整数值")]),t._v(" "),e("li",[e("strong",[t._v("INTSET_ENC_INT64")]),t._v("：int64_t类型的整数值")])]),t._v(" "),e("h3",{attrs:{id:"升级过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#升级过程"}},[t._v("#")]),t._v(" 升级过程")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {\n    uint8_t curenc = intrev32ifbe(is->encoding);\n    uint8_t newenc = _intsetValueEncoding(value);\n    int length = intrev32ifbe(is->length);\n    int prepend = value < 0 ? 1 : 0;\n    \n    // 设置新编码并调整大小\n    is->encoding = intrev32ifbe(newenc);\n    is = intsetResize(is, intrev32ifbe(is->length)+1);\n    \n    // 从后往前移动元素\n    while(length--)\n        _intsetSet(is, length+prepend, _intsetGetEncoded(is, length, curenc));\n    \n    // 添加新元素\n    if (prepend)\n        _intsetSet(is, 0, value);\n    else\n        _intsetSet(is, intrev32ifbe(is->length), value);\n    \n    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);\n    return is;\n}\n")])])]),e("h2",{attrs:{id:"压缩列表-ziplist"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#压缩列表-ziplist"}},[t._v("#")]),t._v(" 压缩列表（ZipList）")]),t._v(" "),e("h3",{attrs:{id:"压缩列表结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#压缩列表结构"}},[t._v("#")]),t._v(" 压缩列表结构")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<zlbytes> <zltail> <zllen> <entry1> <entry2> ... <entryN> <zlend>\n")])])]),e("ul",[e("li",[e("strong",[t._v("zlbytes")]),t._v("：记录整个压缩列表占用的内存字节数")]),t._v(" "),e("li",[e("strong",[t._v("zltail")]),t._v("：记录压缩列表表尾节点距离起始地址的偏移量")]),t._v(" "),e("li",[e("strong",[t._v("zllen")]),t._v("：记录压缩列表包含的节点数量")]),t._v(" "),e("li",[e("strong",[t._v("entryX")]),t._v("：列表节点")]),t._v(" "),e("li",[e("strong",[t._v("zlend")]),t._v("：特殊值0xFF，标记压缩列表的末端")])]),t._v(" "),e("h3",{attrs:{id:"压缩列表节点结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#压缩列表节点结构"}},[t._v("#")]),t._v(" 压缩列表节点结构")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<prevlen> <encoding> <entry-data>\n")])])]),e("p",[e("strong",[t._v("prevlen编码：")])]),t._v(" "),e("ul",[e("li",[t._v("前一节点长度小于254字节：使用1字节保存")]),t._v(" "),e("li",[t._v("前一节点长度大于等于254字节：使用5字节保存")])]),t._v(" "),e("p",[e("strong",[t._v("encoding编码：")])]),t._v(" "),e("ul",[e("li",[t._v("字节数组编码：00、01、10开头")]),t._v(" "),e("li",[t._v("整数编码：11开头")])]),t._v(" "),e("h3",{attrs:{id:"连锁更新问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#连锁更新问题"}},[t._v("#")]),t._v(" 连锁更新问题")]),t._v(" "),e("p",[t._v("当插入或删除节点时，可能引发连锁更新：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 示例：连续多个长度为253字节的节点\n// 插入一个长度大于254字节的节点时\n// 会导致后续节点的prevlen从1字节变为5字节\n// 可能引发连锁反应\n")])])]),e("h2",{attrs:{id:"对象编码选择"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象编码选择"}},[t._v("#")]),t._v(" 对象编码选择")]),t._v(" "),e("h3",{attrs:{id:"字符串对象编码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#字符串对象编码"}},[t._v("#")]),t._v(" 字符串对象编码")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("robj *createStringObject(const char *ptr, size_t len) {\n    if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)\n        return createEmbeddedStringObject(ptr, len);  // embstr编码\n    else\n        return createRawStringObject(ptr, len);       // raw编码\n}\n\nrobj *createStringObjectFromLongLong(long long value) {\n    if (value >= 0 && value < OBJ_SHARED_INTEGERS)\n        return shared.integers[value];  // 共享整数对象\n    else\n        return createObject(OBJ_STRING, sdsfromlonglong(value));\n}\n")])])]),e("h3",{attrs:{id:"列表对象编码转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#列表对象编码转换"}},[t._v("#")]),t._v(" 列表对象编码转换")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("void listTypeConvert(robj *subject, int enc) {\n    if (subject->encoding == OBJ_ENCODING_ZIPLIST) {\n        // ziplist转换为linkedlist\n        unsigned char *zl = subject->ptr;\n        unsigned char *p = ziplistIndex(zl, 0);\n        list *l = listCreate();\n        \n        while (p != NULL) {\n            unsigned char *vstr;\n            unsigned int vlen;\n            long long vlong;\n            \n            if (ziplistGet(p, &vstr, &vlen, &vlong)) {\n                robj *obj;\n                if (vstr) {\n                    obj = createStringObject((char*)vstr, vlen);\n                } else {\n                    obj = createStringObjectFromLongLong(vlong);\n                }\n                listAddNodeTail(l, obj);\n            }\n            p = ziplistNext(zl, p);\n        }\n        \n        subject->ptr = l;\n        subject->encoding = OBJ_ENCODING_LINKEDLIST;\n        zfree(zl);\n    }\n}\n")])])]),e("h2",{attrs:{id:"内存优化策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存优化策略"}},[t._v("#")]),t._v(" 内存优化策略")]),t._v(" "),e("h3",{attrs:{id:"_1-共享对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-共享对象"}},[t._v("#")]),t._v(" 1. 共享对象")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// Redis预创建0-9999的整数对象\nstruct sharedObjectsStruct {\n    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,\n    *colon, *nullbulk, *nullmultibulk, *queued,\n    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,\n    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,\n    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,\n    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,\n    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,\n    *lpush, *emptyscan, *minstring, *maxstring,\n    *select[REDIS_SHARED_SELECT_CMDS],\n    *integers[REDIS_SHARED_INTEGERS],\n    *mbulkhdr[REDIS_SHARED_BULKHDR_LEN],\n    *bulkhdr[REDIS_SHARED_BULKHDR_LEN];\n} shared;\n")])])]),e("h3",{attrs:{id:"_2-引用计数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-引用计数"}},[t._v("#")]),t._v(" 2. 引用计数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('void incrRefCount(robj *o) {\n    o->refcount++;\n}\n\nvoid decrRefCount(robj *o) {\n    if (o->refcount <= 0) {\n        switch(o->type) {\n        case OBJ_STRING: freeStringObject(o); break;\n        case OBJ_LIST: freeListObject(o); break;\n        case OBJ_SET: freeSetObject(o); break;\n        case OBJ_ZSET: freeZsetObject(o); break;\n        case OBJ_HASH: freeHashObject(o); break;\n        default: redisPanic("Unknown object type"); break;\n        }\n        zfree(o);\n    } else {\n        o->refcount--;\n    }\n}\n')])])]),e("h3",{attrs:{id:"_3-对象空转时长"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-对象空转时长"}},[t._v("#")]),t._v(" 3. 对象空转时长")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 计算对象的空转时长\nunsigned long long estimateObjectIdleTime(robj *o) {\n    unsigned long long lruclock = LRU_CLOCK();\n    if (lruclock >= o->lru) {\n        return (lruclock - o->lru) * LRU_CLOCK_RESOLUTION;\n    } else {\n        return (lruclock + (LRU_CLOCK_MAX - o->lru)) *\n                LRU_CLOCK_RESOLUTION;\n    }\n}\n")])])]),e("h2",{attrs:{id:"性能分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能分析"}},[t._v("#")]),t._v(" 性能分析")]),t._v(" "),e("h3",{attrs:{id:"时间复杂度对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度对比"}},[t._v("#")]),t._v(" 时间复杂度对比")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("操作")]),t._v(" "),e("th",[t._v("SDS")]),t._v(" "),e("th",[t._v("C字符串")]),t._v(" "),e("th",[t._v("链表")]),t._v(" "),e("th",[t._v("跳跃表")]),t._v(" "),e("th",[t._v("哈希表")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("获取长度")]),t._v(" "),e("td",[t._v("O(1)")]),t._v(" "),e("td",[t._v("O(N)")]),t._v(" "),e("td",[t._v("O(1)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("-")])]),t._v(" "),e("tr",[e("td",[t._v("查找")]),t._v(" "),e("td",[t._v("O(N)")]),t._v(" "),e("td",[t._v("O(N)")]),t._v(" "),e("td",[t._v("O(N)")]),t._v(" "),e("td",[t._v("O(logN)")]),t._v(" "),e("td",[t._v("O(1)")])]),t._v(" "),e("tr",[e("td",[t._v("插入")]),t._v(" "),e("td",[t._v("O(N)")]),t._v(" "),e("td",[t._v("O(N)")]),t._v(" "),e("td",[t._v("O(1)")]),t._v(" "),e("td",[t._v("O(logN)")]),t._v(" "),e("td",[t._v("O(1)")])]),t._v(" "),e("tr",[e("td",[t._v("删除")]),t._v(" "),e("td",[t._v("O(N)")]),t._v(" "),e("td",[t._v("O(N)")]),t._v(" "),e("td",[t._v("O(1)")]),t._v(" "),e("td",[t._v("O(logN)")]),t._v(" "),e("td",[t._v("O(1)")])]),t._v(" "),e("tr",[e("td",[t._v("范围查询")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("O(N)")]),t._v(" "),e("td",[t._v("O(logN)")]),t._v(" "),e("td",[t._v("-")])])])]),t._v(" "),e("h3",{attrs:{id:"空间复杂度分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度分析"}},[t._v("#")]),t._v(" 空间复杂度分析")]),t._v(" "),e("p",[e("strong",[t._v("SDS空间预分配：")])]),t._v(" "),e("ul",[e("li",[t._v("小于1MB：分配2倍空间")]),t._v(" "),e("li",[t._v("大于1MB：额外分配1MB")]),t._v(" "),e("li",[t._v("平均空间利用率：约50%")])]),t._v(" "),e("p",[e("strong",[t._v("跳跃表空间开销：")])]),t._v(" "),e("ul",[e("li",[t._v("平均每个节点层数：1/(1-p) ≈ 1.33（p=0.25）")]),t._v(" "),e("li",[t._v("额外指针开销：约33%")])]),t._v(" "),e("h2",{attrs:{id:"实际应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实际应用场景"}},[t._v("#")]),t._v(" 实际应用场景")]),t._v(" "),e("h3",{attrs:{id:"_1-缓存系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-缓存系统"}},[t._v("#")]),t._v(" 1. 缓存系统")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 使用Redis作为缓存\nimport redis\n\nr = redis.Redis(host='localhost', port=6379, db=0)\n\n# 字符串缓存\nr.setex('user:1001', 3600, json.dumps(user_data))\nuser_data = json.loads(r.get('user:1001'))\n\n# 哈希缓存\nr.hset('user:1001', 'name', 'John')\nr.hset('user:1001', 'age', 30)\nuser_info = r.hgetall('user:1001')\n")])])]),e("h3",{attrs:{id:"_2-排行榜系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-排行榜系统"}},[t._v("#")]),t._v(" 2. 排行榜系统")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 使用有序集合实现排行榜\n# 添加分数\nr.zadd('leaderboard', {'player1': 1000, 'player2': 1500})\n\n# 获取排行榜\ntop_players = r.zrevrange('leaderboard', 0, 9, withscores=True)\n\n# 获取玩家排名\nrank = r.zrevrank('leaderboard', 'player1')\n")])])]),e("h3",{attrs:{id:"_3-消息队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-消息队列"}},[t._v("#")]),t._v(" 3. 消息队列")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 使用列表实现消息队列\n# 生产者\nr.lpush('task_queue', json.dumps(task_data))\n\n# 消费者\nwhile True:\n    task = r.brpop('task_queue', timeout=1)\n    if task:\n        process_task(json.loads(task[1]))\n")])])]),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("Redis的高性能源于其精心设计的底层数据结构：")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("SDS")]),t._v("：提供了比C字符串更高效的字符串操作")]),t._v(" "),e("li",[e("strong",[t._v("链表")]),t._v("：支持快速的插入和删除操作")]),t._v(" "),e("li",[e("strong",[t._v("字典")]),t._v("：提供O(1)的查找性能，通过渐进式rehash保证性能稳定")]),t._v(" "),e("li",[e("strong",[t._v("跳跃表")]),t._v("：在有序数据上提供O(logN)的查找性能")]),t._v(" "),e("li",[e("strong",[t._v("整数集合")]),t._v("：为小整数集合提供紧凑的存储")]),t._v(" "),e("li",[e("strong",[t._v("压缩列表")]),t._v("：为小数据量提供内存高效的存储")])]),t._v(" "),e("p",[t._v("这些数据结构的巧妙组合和优化，使Redis能够在保持高性能的同时，提供丰富的数据类型和操作，成为现代应用架构中不可或缺的组件。")]),t._v(" "),e("p",[t._v("理解这些底层原理，有助于我们更好地使用Redis，选择合适的数据类型，优化应用性能，并在遇到问题时能够深入分析和解决。")])])}),[],!1,null,null,null);e.default=a.exports}}]);