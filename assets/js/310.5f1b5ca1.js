(window.webpackJsonp=window.webpackJsonp||[]).push([[310],{1127:function(e,t,n){"use strict";n.r(t);var r=n(1),s=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("点击勘误"),t("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[e._v("issues"),t("OutboundLink")],1),e._v("，哪吒感谢大家的阅读")])]),e._v(" "),t("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),e._v(" "),t("h2",{attrs:{id:"dubbo-bug"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo-bug"}},[e._v("#")]),e._v(" dubbo-bug")]),e._v(" "),t("p",[e._v("某天运营反馈，点了⼀次保存，但是后台出现了3条数据，我当时就想，不应该啊，这代码我⼏万年没\n动了，我当时就叫他先别操作了，保留⼀下现场，我去排查⼀下。")]),e._v(" "),t("p",[e._v("dubbo的xml配置⽅式改成了注解的⽅式。")]),e._v(" "),t("p",[e._v("其实dubbo配置的⽅式有很多种，⼤家⽤的最多的就是xml配置的⽅式，如果不需要重试次数，我们会\n加上重试次数为0，因为他默认是有多次的。")]),e._v(" "),t("p",[e._v("dubbo版本：2.6.2")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<dubbo:reference id="testService"\ninterface="heiidea.trade.service.sdk.interfice.TestService" retries="0"/>\n')])])]),t("p",[e._v("或者使⽤注解的⽅式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@Reference(retries =0)\n")])])]),t("p",[e._v("采⽤@Reference注解配置重试次数")]),e._v(" "),t("p",[e._v("⾸先是都找到了dubbo重试的代码位置（启动dubbo项⽬，到调⽤接⼝时，F5进⼊⽅法，会跳转到\nInvokerInvocationHandler中的invoke⽅法中，继续跟踪进⼊MockClusterInvoker中的invoke⽅法，然后\n进⼊AbstractClusterInvoker中的invoke⽅法中，这⾥主要是拿到配置的负载均衡策略，后⾯会到\nFailoverClusterInvoker的doInvoke⽅法中）。")]),e._v(" "),t("p",[e._v("重点来了，这⾥会获取配置的retries值，可以看到上⾯配置的是0，但是取出来居然是null")]),e._v(" "),t("p",[e._v("所以会返回defaultValue，加上本身调⽤的那⼀次，计算之后就会为3")]),e._v(" "),t("p",[e._v("所以可以发现，采⽤@Reference注解的形式配置retries为0时，dubbo重试次数为2次（3中包含本身调\n⽤的那次）。")]),e._v(" "),t("p",[e._v("后⾯是采⽤ dubbo:reference 标签的⽅式：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<dubbo:reference id="testService"\ninterface="heiidea.trade.service.sdk.interfice.TestService" retries="0"/>\n\nprotocol="dubbo" check="false" retries="0" timeout="3000"/>\n\n')])])]),t("p",[e._v("⽅式如上，在获取属性的时候，可以看到获得的值为0，和注解形式配置的⼀致")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("所以可以发现，采⽤ dubbo:reference 标签形式配置retries为0时，dubbo重试次数为0（1为本身调⽤的\n那次）。\n")])])]),t("p",[e._v("加上本身调⽤的那⼀次，计算之后就会为1")]),e._v(" "),t("h2",{attrs:{id:"原因分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原因分析"}},[e._v("#")]),e._v(" 原因分析")]),e._v(" "),t("p",[e._v("⾸先是@Reference注解形式：")]),e._v(" "),t("p",[e._v("dubbo会把每个接⼝先解析为ReferenceBean，加上ReferenceBean实现了FactoryBean接⼝，所以在注\n⼊的时候，会调⽤getObject⽅法，⽣成代理对象。")]),e._v(" "),t("p",[e._v("但是这不是关键，因为到这⼀步时，所有的属性都已经加载完成，所以需要找到dubbo解析注解中属性\n的代码位置。")]),e._v(" "),t("p",[e._v("dubbo会使⽤⾃定义驱动器ReferenceAnnotationBeanPostProcessor来注⼊属性，⽽具体执⾏注⼊的代\n码位置是在ReferenceAnnotationBeanPostProcessor类的postProcessPropertyValues⽅法中调⽤inject\n⽅法执⾏的。")]),e._v(" "),t("p",[e._v("重点来了，因为采⽤标签时，是采⽤@Autowired注解注⼊，所以是采⽤spring原⽣⽅式注⼊，⽽在采⽤\n@Reference注解时，注⼊时会⾛到dubbo⾃⼰的ReferenceAnnotationBeanPostProcessor中私有内部\n类ReferenceFieldElement的inject⽅法中，然后调⽤buildReferenceBean创建ReferenceBean。")]),e._v(" "),t("p",[e._v("离原因越来越近了，在该⽅法中可以看到beanBuilder中的retries值还是0，说明到这⼀步还没有被解析\n为null")]),e._v(" "),t("p",[e._v("继续往下⾛，调⽤build⽅法中的configureBean时，在第⼀步preConfigureBean中⽅法，在该⽅法中会\n创建AnnotationPropertyValuesAdapter对象，在该对象构造⽅法中会调⽤adapt⽅法，然后⾛到\nAnnotationUtils中的getAttributes⽅法中，有⼀个关键⽅法nullSafeEquals，该⽅法会传⼊当前属性值和\n默认值。")]),e._v(" "),t("p",[e._v("如果相等，则会忽略掉该属性，然后将符合条件的属性放⼊actualAttributes这个map中，⽽我们的\nretries属性是0，和默认值⼀致，所以map中不会保存retries属性的值，只有timeout属性，因此出现了\n后⾯获取的值为null。")]),e._v(" "),t("p",[e._v("注解⽅式debug告⼀段落。")]),e._v(" "),t("p",[e._v("标签形式⾛到inject时，会和注解形式有所不同，采⽤该标签时，dubbo会使⽤⾃定义的名\n称空间解析器去解析，很容易理解，spring也不知道它⾃定义标签⾥⾯那些玩意⼉是什么意思，所以\ndubbo会继承spring的。")]),e._v(" "),t("p",[e._v("NamespaceHandlerSupport，采⽤⾃定义的DubboNamespaceHandler解析器来解析的标签")]),e._v(" "),t("p",[e._v("然后调⽤该类中的parse⽅法进⾏解析，⽽解析retries的地⽅就是获取class（此时的class就是上图绿⾊\n标明的ReferenceBean的class，其⽗类中有好多好多set⽅法，其中就包含setRetries⽅法）中所有的⽅\n法，过滤出set开头的⽅法，然后切割出属性名，放⼊属性池中，可以看到此处解析出的值为0，并不为\nnull")]),e._v(" "),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),t("p",[e._v("解析重试次数Retries")]),e._v(" "),t("ol",[t("li",[e._v("@Reference注解形式：采⽤dubbo⾃⼰的驱动器ReferenceAnnotationBeanPostProcessor来注⼊属性，")]),e._v(" "),t("li",[e._v("在ReferenceAnnotationBeanPostProcessor类的postProcessPropertyValues⽅法中调⽤inject⽅法执⾏的。")])]),e._v(" "),t("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}})])}),[],!1,null,null,null);t.default=s.exports}}]);