(window.webpackJsonp=window.webpackJsonp||[]).push([[343],{1165:function(s,t,a){"use strict";a.r(t);var e=a(1),r=Object(e.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("blockquote",[t("p",[s._v("点击勘误"),t("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[s._v("issues"),t("OutboundLink")],1),s._v("，哪吒感谢大家的阅读")])]),s._v(" "),t("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),s._v(" "),t("h2",{attrs:{id:"项目中缓存是如何使用的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#项目中缓存是如何使用的"}},[s._v("#")]),s._v(" 项目中缓存是如何使用的")]),s._v(" "),t("h3",{attrs:{id:"为什么要用缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用缓存"}},[s._v("#")]),s._v(" 为什么要用缓存？")]),s._v(" "),t("p",[s._v("用缓存，主要有两个用途：高性能、高并发。")]),s._v(" "),t("h3",{attrs:{id:"高性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高性能"}},[s._v("#")]),s._v(" 高性能")]),s._v(" "),t("p",[s._v("假设这么个场景，你有个操作，一个请求过来，吭哧吭哧你各种乱七八糟操作 mysql，半天查出来一个结果，耗时 600ms。但是这个结果可能接下来几个小时都不会变了，或者变了也可以不用立即反馈给用户。那么此时咋办？")]),s._v(" "),t("p",[s._v("缓存啊，折腾 600ms 查出来的结果，扔缓存里，一个 key 对应一个 value，下次再有人查，别走 mysql 折腾 600ms 了，直接从缓存里，通过一个 key 查出来一个 value，2ms 搞定。性能提升 300 倍。")]),s._v(" "),t("p",[s._v("就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直接将查询出来的结果放在缓存中，后面直接读缓存就好。")]),s._v(" "),t("h3",{attrs:{id:"高并发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高并发"}},[s._v("#")]),s._v(" 高并发")]),s._v(" "),t("p",[s._v("mysql 这么重的数据库，压根儿设计不是让你玩儿高并发的，虽然也可以玩儿，但是天然支持不好。mysql 单机支撑到 2000QPS 也开始容易报警了。")]),s._v(" "),t("p",[s._v("所以要是你有个系统，高峰期一秒钟过来的请求有 1 万，那一个 mysql 单机绝对会死掉。你这个时候就只能上缓存，把很多数据放缓存，别放 mysql。缓存功能简单，说白了就是 key-value 式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发 so easy。单机承载并发量是 mysql 单机的几十倍。")]),s._v(" "),t("p",[s._v("缓存是走内存的，内存天然就支撑高并发。")])])}),[],!1,null,null,null);t.default=r.exports}}]);