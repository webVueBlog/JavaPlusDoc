(window.webpackJsonp=window.webpackJsonp||[]).push([[219],{1012:function(t,a,s){"use strict";s.r(a);var e=s(1),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("点击勘误"),a("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[t._v("issues"),a("OutboundLink")],1),t._v("，哪吒感谢大家的阅读")])]),t._v(" "),a("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),t._v(" "),a("h2",{attrs:{id:"深入解析java泛型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入解析java泛型"}},[t._v("#")]),t._v(" 深入解析Java泛型")]),t._v(" "),a("p",[t._v("Java 在 1.5 时增加了泛型机制")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Arraylist {\n    private Object[] objs;\n    private int i = 0;\n    public void add(Object obj) {\n        objs[i++] = obj;\n    }\n    \n    public Object get(int i) {\n        return objs[i];\n    }\n}\n")])])]),a("ol",[a("li",[t._v("Arraylist 可以存放任何类型的数据（既可以存字符串，也可以混入日期），因为所有类都继承自 Object 类。")]),t._v(" "),a("li",[t._v("从 Arraylist 取出数据的时候需要强制类型转换，因为编译器并不能确定你取的是字符串还是日期。")])]),t._v(" "),a("p",[t._v("1）类型参数化")]),t._v(" "),a("p",[t._v("泛型的本质是参数化类型，也就是说，在定义类、接口或方法时，可以使用一个或多个类型参数来表示参数化类型。")]),t._v(" "),a("p",[t._v("2）类型擦除")]),t._v(" "),a("p",[t._v("在 Java 的泛型机制中，有两个重要的概念：类型擦除和通配符。")]),t._v(" "),a("p",[t._v("泛型在编译时会将泛型类型擦除，将泛型类型替换成 Object 类型。这是为了向后兼容，避免对原有的 Java 代码造成影响。")]),t._v(" "),a("p",[t._v("3）通配符")]),t._v(" "),a("p",[t._v("通配符用于表示某种未知的类型，例如 List<?> 表示一个可以存储任何类型对象的 List，但是不能对其中的元素进行添加操作。通配符可以用来解决类型不确定的情况，例如在方法参数或返回值中使用。")])])}),[],!1,null,null,null);a.default=n.exports}}]);