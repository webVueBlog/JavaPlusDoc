(window.webpackJsonp=window.webpackJsonp||[]).push([[385],{1208:function(t,e,n){"use strict";n.r(e);var r=n(1),o=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("blockquote",[e("p",[t._v("点击勘误"),e("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[t._v("issues"),e("OutboundLink")],1),t._v("，哪吒感谢大家的阅读")])]),t._v(" "),e("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),t._v(" "),e("h2",{attrs:{id:"springaop扫盲"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#springaop扫盲"}},[t._v("#")]),t._v(" SpringAOP扫盲")]),t._v(" "),e("p",[t._v("AOP 是 Spring 体系中非常重要的两个概念之一（另外一个是 IoC），SpringBoot 项目中使用 AOP 技术为 controller 层添加一个切面来实现接口访问的统一日志记录。")]),t._v(" "),e("p",[t._v("一、关于 AOP")]),t._v(" "),e("p",[t._v("AOP，也就是 Aspect-oriented Programming，译为面向切面编程，是计算机科学中的一个设计思想，旨在通过切面技术为业务主体增加额外的通知（Advice），从而对声明为“切点”（Pointcut）的代码块进行统一管理和装饰。")]),t._v(" "),e("p",[t._v("这种思想非常适用于，将那些与核心业务不那么密切关联的功能添加到程序中")]),t._v(" "),e("p",[t._v("AOP 是对面向对象编程（Object-oriented Programming，俗称 OOP）的一种补充，OOP 的核心单元是类（class），而 AOP 的核心单元是切面（Aspect）。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而降低耦合度，提高程序的可重用性，同时也提高了开发效率。")]),t._v(" "),e("p",[t._v("我们可以简单的把 AOP 理解为贯穿于方法之中，在方法执行前、执行时、执行后、返回值后、异常后要执行的操作。")]),t._v(" "),e("p",[t._v("二、AOP 的相关术语")]),t._v(" "),e("p",[t._v("AOP 涉及到的 5 个关键术语：")]),t._v(" "),e("p",[t._v("1）横切关注点，从每个方法中抽取出来的同一类非核心业务")]),t._v(" "),e("p",[t._v("2）切面（Aspect），对横切关注点进行封装的类，每个关注点体现为一个通知方法；通常使用 @Aspect 注解来定义切面。")]),t._v(" "),e("p",[t._v("3）通知（Advice），切面必须要完成的各个具体工作，比如我们的日志切面需要记录接口调用前后的时长，就需要在调用接口前后记录时间，再取差值。通知的方式有五种：")]),t._v(" "),e("ul",[e("li",[t._v("@Before：通知方法会在目标方法调用之前执行")]),t._v(" "),e("li",[t._v("@After：通知方法会在目标方法调用后执行")]),t._v(" "),e("li",[t._v("@AfterReturning：通知方法会在目标方法返回后执行")]),t._v(" "),e("li",[t._v("@AfterThrowing：通知方法会在目标方法抛出异常后执行")]),t._v(" "),e("li",[t._v("@Around：把整个目标方法包裹起来，在被调用前和调用之后分别执行通知方法")])]),t._v(" "),e("p",[t._v("4）连接点（JoinPoint），通知应用的时机，比如接口方法被调用时就是日志切面的连接点。")]),t._v(" "),e("p",[t._v("5）切点（Pointcut），通知功能被应用的范围，比如本篇日志切面的应用范围是所有 controller 的接口。通常使用 @Pointcut 注解来定义切点表达式。")]),t._v(" "),e("h2",{attrs:{id:"实操-aop-记录接口访问日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实操-aop-记录接口访问日志"}},[t._v("#")]),t._v(" 实操 AOP 记录接口访问日志")]),t._v(" "),e("p",[t._v("第一步，在 Spring Boot 项目的 pom.xml 文件中添加 spring-boot-starter-aop 依赖。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n")])])]),e("p",[t._v("第二步，添加日志信息封装类 WebLog，用于记录什么样的操作、操作的人是谁、开始时间、花费的时间、操作的路径、操作的方法名、操作主机的 IP、请求参数、返回结果等。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("/**\n * Controller层的日志封装类\n */\npublic class WebLog {\n\tprivate String description;\n\tprivate String username;\n\tprivate Long startTime;\n\tprivate Integer spendTime;\n\tprivate String basePath;\n\tprivate String uri;\n\tprivate String url;\n\tprivate String method;\n\tprivate String ip;\n\tprivate Object parameter;\n\tprivate Object result;\n\t//省略了getter,setter方法\n}\n")])])]),e("p",[t._v("第三步，添加统一日志处理切面 WebLogAspect。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('/**\n * 统一日志处理切面\n */\n@Aspect\n@Component\n@Order(1)\npublic class WebLogAspect {\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(WebLogAspect.class);\n\n\t@Pointcut("execution(public * com.codingmore.controller.*.*(..))")\n\tpublic void webLog() {\n\t}\n\n\t@Before("webLog()")\n\tpublic void doBefore(JoinPoint joinPoint) throws Throwable {\n\t}\n\n\t@AfterReturning(value = "webLog()", returning = "ret")\n\tpublic void doAfterReturning(Object ret) throws Throwable {\n\t}\n\n\t@Around("webLog()")\n\tpublic Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {\n\t\tlong startTime = System.currentTimeMillis();\n\t\t//获取当前请求对象\n\t\tServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n\t\tHttpServletRequest request = attributes.getRequest();\n\t\t//记录请求信息(通过Logstash传入Elasticsearch)\n\t\tWebLog webLog = new WebLog();\n\t\tObject result = joinPoint.proceed();\n\t\tSignature signature = joinPoint.getSignature();\n\t\tMethodSignature methodSignature = (MethodSignature) signature;\n\t\tMethod method = methodSignature.getMethod();\n\t\tif (method.isAnnotationPresent(ApiOperation.class)) {\n\t\t\tApiOperation log = method.getAnnotation(ApiOperation.class);\n\t\t\twebLog.setDescription(log.value());\n\t\t}\n\t\tlong endTime = System.currentTimeMillis();\n\t\tString urlStr = request.getRequestURL().toString();\n\t\twebLog.setBasePath(StrUtil.removeSuffix(urlStr, URLUtil.url(urlStr).getPath()));\n\t\twebLog.setIp(request.getRemoteUser());\n\t\tMap<String,Object> logMap = new HashMap<>();\n\t\tlogMap.put("spendTime",webLog.getSpendTime());\n\t\tlogMap.put("description",webLog.getDescription());\n\t\tLOGGER.info("{}", JSONUtil.parse(webLog));\n\t\treturn result;\n\t}\n}\n')])])])])}),[],!1,null,null,null);e.default=o.exports}}]);