(window.webpackJsonp=window.webpackJsonp||[]).push([[394],{1217:function(r,t,e){"use strict";e.r(t);var a=e(1),o=Object(a.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("blockquote",[t("p",[r._v("点击勘误"),t("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[r._v("issues"),t("OutboundLink")],1),r._v("，哪吒感谢大家的阅读")])]),r._v(" "),t("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),r._v(" "),t("h2",{attrs:{id:"springboot整合quartz"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springboot整合quartz"}},[r._v("#")]),r._v(" SpringBoot整合Quartz")]),r._v(" "),t("p",[r._v("开源任务调度框架。")]),r._v(" "),t("p",[r._v("在使用 Quartz 之前，让我们先来搞清楚 4 个核心概念：")]),r._v(" "),t("ol",[t("li",[r._v("Job：任务，要执行的具体内容。")]),r._v(" "),t("li",[r._v("JobDetail：任务详情，Job 是它要执行的内容，同时包含了这个任务调度的策略和方案。")]),r._v(" "),t("li",[r._v("Trigger：触发器，可以通过 Cron 表达式来指定任务执行的时间。")]),r._v(" "),t("li",[r._v("Scheduler：调度器，可以注册多个 JobDetail 和 Trigger，用来调度、暂停和删除任务。")])]),r._v(" "),t("h2",{attrs:{id:"整合-quartz"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#整合-quartz"}},[r._v("#")]),r._v(" 整合 Quartz")]),r._v(" "),t("p",[r._v("Quartz 存储任务的方式有两种，一种是使用内存，另外一种是使用数据库。内存在程序重启后就丢失了，所以我们这次使用数据库的方式来进行任务的持久化。")]),r._v(" "),t("p",[r._v("第一步，在 pom.xml 文件中添加 Quartz 的 starter。")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-quartz</artifactId>\n    <version>2.6.7</version>\n</dependency>\n")])])]),t("p",[r._v("第二步，在 application.yml 添加 Quartz 相关配置，配置说明直接看注释。")]),r._v(" "),t("div",{staticClass:"language-html extra-class"},[t("pre",{pre:!0,attrs:{class:"language-html"}},[t("code",[r._v("spring:\n  quartz:\n    job-store-type: jdbc # 默认为内存 memory 的方式，这里我们使用数据库的形式\n    wait-for-jobs-to-complete-on-shutdown: true # 关闭时等待任务完成\n    overwrite-existing-jobs: true # 可以覆盖已有的任务\n    jdbc:\n      initialize-schema: never # 是否自动使用 SQL 初始化 Quartz 表结构\n    properties: # quartz原生配置\n      org:\n        quartz:\n          scheduler:\n            instanceName: scheduler # 调度器实例名称\n            instanceId: AUTO # 调度器实例ID自动生成\n          # JobStore 相关配置\n          jobStore:\n            class: org.quartz.impl.jdbcjobstore.JobStoreTX # JobStore 实现类\n            driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate # 使用完全兼容JDBC的驱动\n            tablePrefix: QRTZ_ # Quartz 表前缀\n            useProperties: false # 是否将JobDataMap中的属性转为字符串存储\n          # 线程池相关配置\n          threadPool:\n            threadCount: 25 # 线程池大小。默认为 10 。\n            threadPriority: 5 # 线程优先级\n            class: org.quartz.simpl.SimpleThreadPool # 指定线程池实现类，对调度器提供固定大小的线程池\n")])])]),t("p",[r._v("Quartz 默认使用的是内存的方式来存储任务，为了持久化，我们这里改为 JDBC 的形式，并且指定 spring.quartz.jdbc.initialize-schema=never，这样我们可以手动创建数据表。因为该值的另外两个选项ALWAYS和EMBEDDED都不太符合我们的要求：")]),r._v(" "),t("ul",[t("li",[r._v("ALWAYS：每次都初始化")]),r._v(" "),t("li",[r._v("EMBEDDED：只初始化嵌入式数据库，比如说 H2、HSQL")])]),r._v(" "),t("p",[r._v("剩下的就是对 Quartz 的 scheduler、jobStore 和 threadPool 配置。")]),r._v(" "),t("p",[r._v("第三步，创建任务调度的接口 IScheduleService，定义三个方法，分别是通过 Cron 表达式来调度任务、指定时间来调度任务，以及取消任务。")]),r._v(" "),t("p",[r._v("第四步，创建任务调度业务实现类 ScheduleServiceImpl，通过Scheduler、CronTrigger、JobDetail的API来实现对应的方法。")]),r._v(" "),t("p",[r._v("第五步，定义好要执行的任务，继承 QuartzJobBean 类，实现 executeInternal 方法，这里只定义一个定时发布文章的任务。")]),r._v(" "),t("p",[r._v("第六步，发布文章的接口里 PostsServiceImpl 添加定时发布的任务调度方法。")]),r._v(" "),t("p",[r._v("查看 Quartz 的数据表 qrtz_cron_triggers，发现任务已经添加进来了。")]),r._v(" "),t("p",[r._v("qrtz_job_details 表里也可以查看具体的任务详情。")]),r._v(" "),t("p",[r._v("文章定时发布的时间到了之后，在日志里也可以看到 Quartz 的执行日志。")])])}),[],!1,null,null,null);t.default=o.exports}}]);