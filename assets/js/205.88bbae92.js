(window.webpackJsonp=window.webpackJsonp||[]).push([[205],{997:function(e,a,v){"use strict";v.r(a);var _=v(1),s=Object(_.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("blockquote",[a("p",[e._v("点击勘误"),a("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[e._v("issues"),a("OutboundLink")],1),e._v("，哪吒感谢大家的阅读")])]),e._v(" "),a("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),e._v(" "),a("h2",{attrs:{id:"详解weakhashmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#详解weakhashmap"}},[e._v("#")]),e._v(" 详解WeakHashMap")]),e._v(" "),a("p",[e._v("在Java中，我们一般都会使用到Map，比如HashMap这样的具体实现。更高级一点，我们可能会使用WeakHashMap。")]),e._v(" "),a("p",[e._v("WeakHashMap其实和HashMap大多数行为是一样的，只是WeakHashMap不会阻止GC回收key对象（不是value），那么WeakHashMap是怎么做到的呢。")]),e._v(" "),a("p",[e._v("在开始WeakHashMap之前，我们先要对弱引用有一定的了解。")]),e._v(" "),a("p",[e._v("在Java中，有四种引用类型")]),e._v(" "),a("ol",[a("li",[e._v("强引用(Strong Reference)，我们正常编码时默认的引用类型，强应用之所以为强，是因为如果一个对象到GC Roots强引用可到达，就可以阻止GC回收该对象")]),e._v(" "),a("li",[e._v("软引用（Soft Reference）阻止GC回收的能力相对弱一些，如果是软引用可以到达，那么这个对象会停留在内存更时间上长一些。当内存不足时垃圾回收器才会回收这些软引用可到达的对象")]),e._v(" "),a("li",[e._v("弱引用（WeakReference）无法阻止GC回收，如果一个对象时弱引用可到达，那么在下一个GC回收执行时，该对象就会被回收掉。")]),e._v(" "),a("li",[e._v("虚引用（Phantom Reference）十分脆弱，它的唯一作用就是当其指向的对象被回收之后，自己被加入到引用队列，用作记录该引用指向的对象已被销毁")])]),e._v(" "),a("p",[e._v("这其中还有一个概念叫做引用队列(Reference Queue)")]),e._v(" "),a("ol",[a("li",[e._v("一般情况下，一个对象标记为垃圾（并不代表回收了）后，会加入到引用队列。")]),e._v(" "),a("li",[e._v("对于虚引用来说，它指向的对象会只有被回收后才会加入引用队列，所以可以用作记录该引用指向的对象是否回收。")])]),e._v(" "),a("p",[e._v("WeakHashMap如何不阻止对象回收呢")]),e._v(" "),a("p",[e._v("源码所示，")]),e._v(" "),a("ol",[a("li",[e._v("WeakHashMap的Entry继承了WeakReference。")]),e._v(" "),a("li",[e._v("其中Key作为了WeakReference指向的对象")]),e._v(" "),a("li",[e._v("因此WeakHashMap利用了WeakReference的机制来实现不阻止GC回收Key")])]),e._v(" "),a("h3",{attrs:{id:"如何删除被回收的key数据呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何删除被回收的key数据呢"}},[e._v("#")]),e._v(" 如何删除被回收的key数据呢")]),e._v(" "),a("p",[e._v("关于WeakHashMap有这样的描述，当key不再引用时，其对应的key/value也会被移除。")]),e._v(" "),a("p",[e._v("那么是如何移除的呢，这里我们通常有两种假设策略")]),e._v(" "),a("ol",[a("li",[e._v("当对象被回收的时候，进行通知")]),e._v(" "),a("li",[e._v("WeakHashMap轮询处理时效的Entry")])]),e._v(" "),a("p",[e._v("而WeakHashMap采用的是轮询的形式，在其put/get/size等方法调用的时候都会预先调用一个poll的方法，来检查并删除失效的Entry")]),e._v(" "),a("p",[e._v("为什么没有使用看似更好的通知呢，我想是因为在Java中没有一个可靠的通知回调，比如大家常说的finalize方法，其实也不是标准的，不同的JVM可以实现不同，甚至是不调用这个方法。")]),e._v(" "),a("p",[e._v("注意：System.gc()并不一定可以工作,建议使用Android Studio的Force GC")])])}),[],!1,null,null,null);a.default=s.exports}}]);