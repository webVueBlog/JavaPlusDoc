(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{947:function(s,a,t){"use strict";t.r(a);var n=t(1),e=Object(n.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("blockquote",[a("p",[s._v("点击勘误"),a("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[s._v("issues"),a("OutboundLink")],1),s._v("，哪吒感谢大家的阅读")])]),s._v(" "),a("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),s._v(" "),a("h2",{attrs:{id:"jvm内存区域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存区域"}},[s._v("#")]),s._v(" JVM内存区域")]),s._v(" "),a("p",[s._v("JVM内存：")]),s._v(" "),a("p",[s._v("线程私有 Thread Local")]),s._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[s._v("程序计数器"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("PC")]),s._v("：指向虚拟机字节码指令的位置"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" 唯一一个无"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("OOM")]),s._v("的区域\n\n虚拟机栈"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("VM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Stack")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 虚拟机栈和线程的生命周期相同；一个线程中，每调用一个方法创建一个栈帧（"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Stack")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Frame")]),s._v("）；\n\n栈帧的结构：本地变量表 "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Local")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Variable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" 操作数栈 "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Operand")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Stank")]),s._v("， 对运行时常理池的引用 "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Runtime")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Constant")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Pool")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Reference")]),s._v(" \n\n异常：线程请求的栈深度大于"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JVM")]),s._v("所允许的深度 "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("StackOverflowError")]),s._v("；若"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JVM")]),s._v("允许动态扩展，若无法申请到足够内存"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("OutOfMemoryError")]),s._v("\n\n本地方法栈："),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Native")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Method")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Stack")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" 异常：线程请求的栈深度大于"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JVM")]),s._v("所允许的深度"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("StackOverflowError")]),s._v("； 若"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JVM")]),s._v("允许动态扩展，若无法申请到足够内存"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("OutOfMemoryError")]),s._v("\n\n")])])]),a("p",[s._v("线程共享 Thread Shared")]),s._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[s._v("方法区（永久代） "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Method")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Area")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 运行时常量池 "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Runtime")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Constant")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Pool")]),s._v("\n\n类实例区（java堆）"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Objects")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 新生代 eden，from survivor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token namespace"}},[s._v("survivor")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" 老年代，异常 "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("OutOfMemoryError")]),s._v("\n\n")])])]),a("p",[s._v("直接内存 Direct Memory")]),s._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[s._v("不受"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JVM")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("GC")]),s._v("管理\n")])])]),a("p",[s._v("JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区\n域【JAVA 堆、方法区】、直接内存。")]),s._v(" "),a("p",[s._v("线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot\nVM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的\n生/死对应)。")]),s._v(" "),a("p",[s._v("线程共享区域随虚拟机的启动/关闭而创建/销毁。\n直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提\n供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用\nDirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java\n堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。")])])}),[],!1,null,null,null);a.default=e.exports}}]);