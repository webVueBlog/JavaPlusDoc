(window.webpackJsonp=window.webpackJsonp||[]).push([[234],{1026:function(t,a,n){"use strict";n.r(a);var s=n(1),i=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("点击勘误"),a("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[t._v("issues"),a("OutboundLink")],1),t._v("，哪吒感谢大家的阅读")])]),t._v(" "),a("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),t._v(" "),a("h2",{attrs:{id:"this与super关键字static"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this与super关键字static"}},[t._v("#")]),t._v(" this与super关键字static")]),t._v(" "),a("p",[t._v("调用当前类的方法；")]),t._v(" "),a("p",[t._v("this() 可以调用当前类的构造方法；")]),t._v(" "),a("p",[t._v("this 可以作为参数在方法中传递；")]),t._v(" "),a("p",[t._v("this 可以作为参数在构造方法中传递；")]),t._v(" "),a("p",[t._v("this 可以作为方法的返回值，返回当前类的对象。")]),t._v(" "),a("p",[t._v("“super 关键字的用法主要有三种。”")]),t._v(" "),a("p",[t._v("指向父类对象；")]),t._v(" "),a("p",[t._v("调用父类的方法；")]),t._v(" "),a("p",[t._v("super() 可以调用父类的构造方法。")]),t._v(" "),a("h3",{attrs:{id:"static"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#static"}},[t._v("#")]),t._v(" static")]),t._v(" "),a("p",[t._v("如果在声明变量的时候使用了 static 关键字，那么这个变量就被称为静态变量。静态变量只在类加载的时候获取一次内存空间，这使得静态变量很节省内存空间。")]),t._v(" "),a("p",[t._v("“静态方法有以下这些特征。”")]),t._v(" "),a("p",[t._v("静态方法属于这个类而不是这个类的对象；")]),t._v(" "),a("p",[t._v("调用静态方法的时候不需要创建这个类的对象；")]),t._v(" "),a("p",[t._v("静态方法可以访问静态变量。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('public class StaticBlock {\n\tstatic {\n\t\tSystem.out.println("静态代码块");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println("main 方法");\n\t}\n}\n')])])]),a("p",[t._v("“静态代码块通常用来初始化一些静态变量，它会优先于 main() 方法执行。”")]),t._v(" "),a("p",[t._v("既然静态代码块先于 main() 方法执行，那没有 main() 方法的 Java 类能执行成功吗？")]),t._v(" "),a("p",[t._v("“Java 1.6 是可以的，但 Java 7 开始就无法执行了。”")]),t._v(" "),a("p",[t._v("“静态代码块在初始集合的时候，真的非常有用。在实际的项目开发中，通常使用静态代码块来加载配置文件到内存当中。”")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("public class Singleton {\n\tprivate Singleton() {}\n\n\tprivate static class SingletonHolder {\n\t\tpublic static final Singleton instance = new Singleton();\n\t}\n\n\tpublic static Singleton getInstance() {\n\t\treturn SingletonHolder.instance;\n\t}\n}\n")])])]),a("p",[t._v("“需要注意的是。第一，静态内部类不能访问外部类的所有成员变量；第二，静态内部类可以访问外部类的所有静态变量，包括私有静态变量。第三，外部类不能声明为 static。”")]),t._v(" "),a("h2",{attrs:{id:"final-关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#final-关键字"}},[t._v("#")]),t._v(" final 关键字")]),t._v(" "),a("p",[t._v("“被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。”")]),t._v(" "),a("p",[t._v("“被 final 修饰的方法不能被重写。如果我们在设计一个类的时候，认为某些方法不应该被重写，就应该把它设计成 final 的。”")]),t._v(" "),a("h3",{attrs:{id:"为什么-string-类要设计成-final-吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么-string-类要设计成-final-吗"}},[t._v("#")]),t._v(" 为什么 String 类要设计成 final 吗？")]),t._v(" "),a("p",[t._v("为了实现字符串常量池")]),t._v(" "),a("p",[t._v("为了线程安全")]),t._v(" "),a("p",[t._v("为了 HashCode 的不可变性")]),t._v(" "),a("h2",{attrs:{id:"instanceof关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#instanceof关键字"}},[t._v("#")]),t._v(" instanceof关键字")]),t._v(" "),a("p",[t._v("用意也非常简单，判断对象是否符合指定的类型，结果要么是 true，要么是 false。在反序列化的时候，instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的话，就容易抛出 ClassCastException 异常。")]),t._v(" "),a("p",[t._v("先用 instanceof 进行类型判断，然后再把 obj 强制转换成我们期望的类型再进行使用。")])])}),[],!1,null,null,null);a.default=i.exports}}]);