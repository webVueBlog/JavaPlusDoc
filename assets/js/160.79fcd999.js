(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{952:function(n,t,a){"use strict";a.r(t);var e=a(1),r=Object(e.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"mysql的innodb原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql的innodb原理"}},[n._v("#")]),n._v(" MySQL的InnoDB原理")]),n._v(" "),t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[n._v("#")]),n._v(" 概述")]),n._v(" "),t("p",[n._v("InnoDB是MySQL的默认存储引擎，支持事务、外键、崩溃恢复等企业级特性。本文深入分析InnoDB的核心原理，包括存储结构、索引机制、事务实现、锁机制、缓冲池管理等关键技术。")]),n._v(" "),t("h2",{attrs:{id:"innodb架构概览"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#innodb架构概览"}},[n._v("#")]),n._v(" InnoDB架构概览")]),n._v(" "),t("h3",{attrs:{id:"整体架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#整体架构"}},[n._v("#")]),n._v(" 整体架构")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("┌─────────────────────────────────────────────────────────────┐\n│                    MySQL Server Layer                       │\n├─────────────────────────────────────────────────────────────┤\n│                     InnoDB Storage Engine                   │\n│                                                             │\n│  ┌─────────────────┐    ┌─────────────────────────────────┐ │\n│  │   Memory Pool   │    │        Disk Files               │ │\n│  │                 │    │                                 │ │\n│  │ ┌─────────────┐ │    │ ┌─────────────┐ ┌─────────────┐ │ │\n│  │ │Buffer Pool  │ │    │ │System       │ │User         │ │ │\n│  │ │             │ │    │ │Tablespace   │ │Tablespaces  │ │ │\n│  │ ├─────────────┤ │    │ │(.ibdata)    │ │(.ibd)       │ │ │\n│  │ │Log Buffer   │ │    │ └─────────────┘ └─────────────┘ │ │\n│  │ │             │ │    │                                 │ │\n│  │ ├─────────────┤ │    │ ┌─────────────┐ ┌─────────────┐ │ │\n│  │ │Change Buffer│ │    │ │Redo Log     │ │Undo Log     │ │ │\n│  │ │             │ │    │ │Files        │ │             │ │ │\n│  │ └─────────────┘ │    │ │(ib_logfile) │ │             │ │ │\n│  └─────────────────┘    │ └─────────────┘ └─────────────┘ │ │\n│                         └─────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────┘\n")])])]),t("h3",{attrs:{id:"核心组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心组件"}},[n._v("#")]),n._v(" 核心组件")]),n._v(" "),t("ol",[t("li",[t("strong",[n._v("Buffer Pool")]),n._v("：缓存数据页和索引页")]),n._v(" "),t("li",[t("strong",[n._v("Log Buffer")]),n._v("：缓存redo log")]),n._v(" "),t("li",[t("strong",[n._v("Change Buffer")]),n._v("：缓存对非唯一二级索引的修改")]),n._v(" "),t("li",[t("strong",[n._v("Adaptive Hash Index")]),n._v("：自适应哈希索引")]),n._v(" "),t("li",[t("strong",[n._v("Redo Log")]),n._v("：重做日志，保证事务持久性")]),n._v(" "),t("li",[t("strong",[n._v("Undo Log")]),n._v("：回滚日志，支持事务回滚和MVCC")])]),n._v(" "),t("h2",{attrs:{id:"存储结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存储结构"}},[n._v("#")]),n._v(" 存储结构")]),n._v(" "),t("h3",{attrs:{id:"表空间-tablespace"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#表空间-tablespace"}},[n._v("#")]),n._v(" 表空间（Tablespace）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("表空间\n├── 段（Segment）\n│   ├── 数据段（叶子节点段）\n│   ├── 索引段（非叶子节点段）\n│   └── 回滚段（Undo段）\n├── 区（Extent）- 64个连续页，1MB\n└── 页（Page）- 16KB\n    ├── 文件头（File Header）\n    ├── 页头（Page Header）\n    ├── 最大最小记录（Infimum + Supremum）\n    ├── 用户记录（User Records）\n    ├── 空闲空间（Free Space）\n    ├── 页目录（Page Directory）\n    └── 文件尾（File Trailer）\n")])])]),t("h3",{attrs:{id:"页结构详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#页结构详解"}},[n._v("#")]),n._v(" 页结构详解")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// InnoDB页结构\nstruct page_t {\n    // 文件头（38字节）\n    struct {\n        uint32_t checksum;          // 校验和\n        uint32_t page_number;       // 页号\n        uint32_t prev_page;         // 前一页\n        uint32_t next_page;         // 后一页\n        uint64_t lsn;              // 最后修改的LSN\n        uint16_t page_type;         // 页类型\n        uint64_t flush_lsn;        // 刷新LSN\n        uint32_t space_id;         // 表空间ID\n    } file_header;\n    \n    // 页头（56字节）\n    struct {\n        uint16_t slot_count;        // 页目录槽数量\n        uint16_t heap_top;          // 堆顶位置\n        uint16_t record_count;      // 记录数量\n        uint16_t max_trx_id;       // 最大事务ID\n        uint16_t page_level;        // 页层级\n        uint64_t index_id;         // 索引ID\n        // ... 其他字段\n    } page_header;\n    \n    // 用户记录区域\n    char user_records[...];\n    \n    // 页目录\n    uint16_t page_directory[...];\n    \n    // 文件尾（8字节）\n    struct {\n        uint32_t checksum;          // 校验和\n        uint32_t lsn_low;          // LSN低位\n    } file_trailer;\n};\n")])])]),t("h3",{attrs:{id:"行格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行格式"}},[n._v("#")]),n._v(" 行格式")]),n._v(" "),t("p",[t("strong",[n._v("Compact行格式：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("┌─────────────┬─────────────┬─────────────┬─────────────┬─────────────┐\n│变长字段长度列表│  NULL标志位  │   记录头信息  │   列1数据    │   列2数据    │\n└─────────────┴─────────────┴─────────────┴─────────────┴─────────────┘\n")])])]),t("p",[t("strong",[n._v("记录头信息（5字节）：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("struct record_header {\n    unsigned deleted_flag:1;     // 删除标记\n    unsigned min_rec_flag:1;     // 最小记录标记\n    unsigned n_owned:4;          // 拥有的记录数\n    unsigned heap_no:13;         // 堆中的位置\n    unsigned record_type:3;      // 记录类型\n    unsigned next_record:16;     // 下一条记录的偏移量\n};\n")])])]),t("h2",{attrs:{id:"索引机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#索引机制"}},[n._v("#")]),n._v(" 索引机制")]),n._v(" "),t("h3",{attrs:{id:"b-树索引结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-树索引结构"}},[n._v("#")]),n._v(" B+树索引结构")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("                    根节点（非叶子节点）\n                   ┌─────┬─────┬─────┐\n                   │ 10  │ 20  │ 30  │\n                   └──┬──┴──┬──┴──┬──┘\n                      │     │     │\n              ┌───────┘     │     └───────┐\n              │             │             │\n         非叶子节点      非叶子节点      非叶子节点\n        ┌─────┬─────┐  ┌─────┬─────┐  ┌─────┬─────┐\n        │  5  │  8  │  │ 15  │ 18  │  │ 25  │ 28  │\n        └──┬──┴──┬──┘  └──┬──┴──┬──┘  └──┬──┴──┬──┘\n           │     │        │     │        │     │\n      ┌────┘     └────┐   │     │        │     └────┐\n      │               │   │     │        │          │\n   叶子节点        叶子节点  ...  ...     ...      叶子节点\n  ┌─┬─┬─┬─┐      ┌─┬─┬─┬─┐                    ┌─┬─┬─┬─┐\n  │1│2│3│4│ ──→  │5│6│7│8│ ──→ ... ──→ ... ──→ │28│29│30│31│\n  └─┴─┴─┴─┘      └─┴─┴─┴─┘                    └─┴─┴─┴─┘\n")])])]),t("h3",{attrs:{id:"聚簇索引-主键索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#聚簇索引-主键索引"}},[n._v("#")]),n._v(" 聚簇索引（主键索引）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- 创建表\nCREATE TABLE users (\n    id INT PRIMARY KEY,\n    name VARCHAR(50),\n    age INT,\n    email VARCHAR(100)\n);\n\n-- 聚簇索引结构\n-- 叶子节点存储完整的行数据\nB+树叶子节点：\n┌─────┬──────────────────────────────────┐\n│ id  │        完整行数据                 │\n├─────┼──────────────────────────────────┤\n│  1  │ (1, 'Alice', 25, 'alice@...')    │\n│  2  │ (2, 'Bob', 30, 'bob@...')        │\n│  3  │ (3, 'Charlie', 28, 'charlie@...')│\n└─────┴──────────────────────────────────┘\n")])])]),t("h3",{attrs:{id:"二级索引-辅助索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二级索引-辅助索引"}},[n._v("#")]),n._v(" 二级索引（辅助索引）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- 创建二级索引\nCREATE INDEX idx_name ON users(name);\n\n-- 二级索引结构\n-- 叶子节点存储索引键值和主键值\nB+树叶子节点：\n┌─────────┬─────────┐\n│  name   │   id    │\n├─────────┼─────────┤\n│ 'Alice' │    1    │\n│ 'Bob'   │    2    │\n│'Charlie'│    3    │\n└─────────┴─────────┘\n")])])]),t("h3",{attrs:{id:"索引查找过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#索引查找过程"}},[n._v("#")]),n._v(" 索引查找过程")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- 通过二级索引查找\nSELECT * FROM users WHERE name = 'Bob';\n\n-- 查找步骤：\n-- 1. 在name索引的B+树中查找'Bob'\n-- 2. 找到对应的主键值id=2\n-- 3. 回表：在聚簇索引中查找id=2的完整记录\n")])])]),t("h3",{attrs:{id:"覆盖索引优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#覆盖索引优化"}},[n._v("#")]),n._v(" 覆盖索引优化")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- 创建覆盖索引\nCREATE INDEX idx_name_age ON users(name, age);\n\n-- 覆盖索引查询（无需回表）\nSELECT name, age FROM users WHERE name = 'Bob';\n\n-- 索引结构：\n┌─────────┬─────┬─────────┐\n│  name   │ age │   id    │\n├─────────┼─────┼─────────┤\n│ 'Alice' │ 25  │    1    │\n│ 'Bob'   │ 30  │    2    │\n│'Charlie'│ 28  │    3    │\n└─────────┴─────┴─────────┘\n")])])]),t("h2",{attrs:{id:"事务实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务实现"}},[n._v("#")]),n._v(" 事务实现")]),n._v(" "),t("h3",{attrs:{id:"acid特性实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#acid特性实现"}},[n._v("#")]),n._v(" ACID特性实现")]),n._v(" "),t("p",[t("strong",[n._v("原子性（Atomicity）")])]),n._v(" "),t("ul",[t("li",[n._v("通过Undo Log实现事务回滚")]),n._v(" "),t("li",[n._v("事务失败时，利用Undo Log撤销所有修改")])]),n._v(" "),t("p",[t("strong",[n._v("一致性（Consistency）")])]),n._v(" "),t("ul",[t("li",[n._v("通过约束检查、触发器等保证数据一致性")]),n._v(" "),t("li",[n._v("事务执行前后，数据库从一个一致性状态转换到另一个一致性状态")])]),n._v(" "),t("p",[t("strong",[n._v("隔离性（Isolation）")])]),n._v(" "),t("ul",[t("li",[n._v("通过锁机制和MVCC实现事务隔离")]),n._v(" "),t("li",[n._v("支持四种隔离级别")])]),n._v(" "),t("p",[t("strong",[n._v("持久性（Durability）")])]),n._v(" "),t("ul",[t("li",[n._v("通过Redo Log实现持久性")]),n._v(" "),t("li",[n._v("事务提交后，修改永久保存")])]),n._v(" "),t("h3",{attrs:{id:"redo-log机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redo-log机制"}},[n._v("#")]),n._v(" Redo Log机制")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// Redo Log记录结构\nstruct redo_log_record {\n    uint8_t type;              // 日志类型\n    uint32_t space_id;         // 表空间ID\n    uint32_t page_number;      // 页号\n    uint16_t offset;           // 页内偏移\n    uint16_t length;           // 数据长度\n    uint64_t lsn;             // 日志序列号\n    char data[];              // 修改的数据\n};\n")])])]),t("p",[t("strong",[n._v("WAL（Write-Ahead Logging）原则：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("1. 修改数据页之前，必须先写Redo Log\n2. 事务提交时，必须先将Redo Log刷盘\n3. 数据页可以延迟刷盘（通过Checkpoint机制）\n")])])]),t("p",[t("strong",[n._v("Redo Log写入流程：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 简化的Redo Log写入流程\nvoid write_redo_log(transaction_t* trx, page_t* page, \n                   uint16_t offset, char* data, uint16_t len) {\n    // 1. 生成LSN\n    uint64_t lsn = generate_lsn();\n    \n    // 2. 构造Redo Log记录\n    redo_log_record_t record;\n    record.type = REDO_INSERT;\n    record.space_id = page->space_id;\n    record.page_number = page->page_number;\n    record.offset = offset;\n    record.length = len;\n    record.lsn = lsn;\n    memcpy(record.data, data, len);\n    \n    // 3. 写入Log Buffer\n    log_buffer_write(&record);\n    \n    // 4. 更新页的LSN\n    page->lsn = lsn;\n    \n    // 5. 根据innodb_flush_log_at_trx_commit决定刷盘时机\n    if (trx->state == TRX_COMMITTING) {\n        log_buffer_flush();\n    }\n}\n")])])]),t("h3",{attrs:{id:"undo-log机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#undo-log机制"}},[n._v("#")]),n._v(" Undo Log机制")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// Undo Log记录结构\nstruct undo_log_record {\n    uint8_t type;              // Undo类型\n    uint64_t trx_id;          // 事务ID\n    uint64_t undo_no;         // Undo序号\n    uint32_t table_id;        // 表ID\n    uint16_t info_bits;       // 信息位\n    char old_data[];          // 旧数据\n};\n")])])]),t("p",[t("strong",[n._v("Undo Log类型：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("#define TRX_UNDO_INSERT_REC    11  // INSERT操作的Undo\n#define TRX_UNDO_UPD_EXIST_REC 12  // UPDATE操作的Undo\n#define TRX_UNDO_UPD_DEL_REC   13  // DELETE操作的Undo\n#define TRX_UNDO_DEL_MARK_REC  14  // 删除标记的Undo\n")])])]),t("h3",{attrs:{id:"mvcc实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvcc实现"}},[n._v("#")]),n._v(" MVCC实现")]),n._v(" "),t("p",[t("strong",[n._v("行记录的隐藏字段：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("struct row_record {\n    // 用户定义的列\n    char user_columns[];\n    \n    // 隐藏字段\n    uint64_t trx_id;          // 创建该记录的事务ID\n    uint64_t roll_pointer;    // 回滚指针，指向Undo Log\n};\n")])])]),t("p",[t("strong",[n._v("Read View结构：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("struct read_view {\n    uint64_t low_limit_id;    // 最大事务ID + 1\n    uint64_t up_limit_id;     // 最小活跃事务ID\n    uint64_t creator_trx_id;  // 创建该Read View的事务ID\n    trx_id_t* trx_ids;        // 活跃事务ID数组\n    uint32_t n_trx_ids;       // 活跃事务数量\n};\n")])])]),t("p",[t("strong",[n._v("可见性判断算法：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("bool is_visible(read_view_t* view, uint64_t trx_id) {\n    // 1. 如果trx_id等于当前事务ID，可见\n    if (trx_id == view->creator_trx_id) {\n        return true;\n    }\n    \n    // 2. 如果trx_id小于最小活跃事务ID，已提交，可见\n    if (trx_id < view->up_limit_id) {\n        return true;\n    }\n    \n    // 3. 如果trx_id大于等于最大事务ID，不可见\n    if (trx_id >= view->low_limit_id) {\n        return false;\n    }\n    \n    // 4. 检查是否在活跃事务列表中\n    for (int i = 0; i < view->n_trx_ids; i++) {\n        if (view->trx_ids[i] == trx_id) {\n            return false;  // 活跃事务，不可见\n        }\n    }\n    \n    return true;  // 已提交事务，可见\n}\n")])])]),t("h2",{attrs:{id:"锁机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁机制"}},[n._v("#")]),n._v(" 锁机制")]),n._v(" "),t("h3",{attrs:{id:"锁的分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁的分类"}},[n._v("#")]),n._v(" 锁的分类")]),n._v(" "),t("p",[t("strong",[n._v("按锁的粒度：")])]),n._v(" "),t("ul",[t("li",[n._v("表级锁（Table Lock）")]),n._v(" "),t("li",[n._v("行级锁（Row Lock）")]),n._v(" "),t("li",[n._v("页级锁（Page Lock）")])]),n._v(" "),t("p",[t("strong",[n._v("按锁的模式：")])]),n._v(" "),t("ul",[t("li",[n._v("共享锁（S Lock）")]),n._v(" "),t("li",[n._v("排他锁（X Lock）")]),n._v(" "),t("li",[n._v("意向共享锁（IS Lock）")]),n._v(" "),t("li",[n._v("意向排他锁（IX Lock）")])]),n._v(" "),t("p",[t("strong",[n._v("按锁的算法：")])]),n._v(" "),t("ul",[t("li",[n._v("Record Lock（记录锁）")]),n._v(" "),t("li",[n._v("Gap Lock（间隙锁）")]),n._v(" "),t("li",[n._v("Next-Key Lock（临键锁）")])]),n._v(" "),t("h3",{attrs:{id:"锁兼容性矩阵"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁兼容性矩阵"}},[n._v("#")]),n._v(" 锁兼容性矩阵")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("     │  S  │  X  │ IS  │ IX  │\n─────┼─────┼─────┼─────┼─────┤\n  S  │  ✓  │  ✗  │  ✓  │  ✗  │\n  X  │  ✗  │  ✗  │  ✗  │  ✗  │\n IS  │  ✓  │  ✗  │  ✓  │  ✓  │\n IX  │  ✗  │  ✗  │  ✓  │  ✓  │\n")])])]),t("h3",{attrs:{id:"next-key-lock实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#next-key-lock实现"}},[n._v("#")]),n._v(" Next-Key Lock实现")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- 示例表\nCREATE TABLE test (\n    id INT PRIMARY KEY,\n    value INT,\n    KEY idx_value (value)\n);\n\nINSERT INTO test VALUES (1, 10), (5, 20), (10, 30), (15, 40);\n\n-- 在REPEATABLE READ隔离级别下\nSELECT * FROM test WHERE value = 20 FOR UPDATE;\n\n-- 加锁范围：\n-- Record Lock: value = 20的记录\n-- Gap Lock: (10, 20) 和 (20, 30) 的间隙\n-- Next-Key Lock: (10, 20] 和 (20, 30)\n")])])]),t("h3",{attrs:{id:"死锁检测与处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死锁检测与处理"}},[n._v("#")]),n._v(" 死锁检测与处理")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 死锁检测算法（简化版）\nbool detect_deadlock(transaction_t* trx) {\n    // 构建等待图\n    wait_graph_t graph;\n    build_wait_graph(&graph);\n    \n    // 深度优先搜索检测环\n    for (int i = 0; i < graph.node_count; i++) {\n        if (dfs_detect_cycle(&graph, i)) {\n            // 发现死锁，选择代价最小的事务回滚\n            transaction_t* victim = choose_victim(&graph);\n            rollback_transaction(victim);\n            return true;\n        }\n    }\n    \n    return false;\n}\n")])])]),t("h2",{attrs:{id:"buffer-pool管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#buffer-pool管理"}},[n._v("#")]),n._v(" Buffer Pool管理")]),n._v(" "),t("h3",{attrs:{id:"buffer-pool结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#buffer-pool结构"}},[n._v("#")]),n._v(" Buffer Pool结构")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("struct buffer_pool {\n    buf_page_t* pages;           // 页数组\n    buf_page_hash_t* page_hash;  // 页哈希表\n    UT_LIST_BASE_NODE_T(buf_page_t) free_list;  // 空闲页链表\n    UT_LIST_BASE_NODE_T(buf_page_t) LRU_list;   // LRU链表\n    UT_LIST_BASE_NODE_T(buf_page_t) flush_list; // 脏页链表\n    \n    mutex_t mutex;               // 互斥锁\n    uint32_t curr_size;         // 当前大小\n    uint32_t max_size;          // 最大大小\n};\n")])])]),t("h3",{attrs:{id:"lru算法优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lru算法优化"}},[n._v("#")]),n._v(" LRU算法优化")]),n._v(" "),t("p",[t("strong",[n._v("传统LRU问题：")])]),n._v(" "),t("ul",[t("li",[n._v("全表扫描会污染Buffer Pool")]),n._v(" "),t("li",[n._v("预读的页面可能不会被使用")])]),n._v(" "),t("p",[t("strong",[n._v("InnoDB的改进LRU：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("LRU链表分为两部分：\n┌─────────────────┬─────────────────┐\n│   Young区域     │    Old区域      │\n│   (热点数据)    │   (冷数据)      │\n└─────────────────┴─────────────────┘\n     ↑                    ↑\n   5/8 * LRU           3/8 * LRU\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 改进的LRU算法\nvoid access_page(buf_page_t* page) {\n    if (page->in_young_region) {\n        // 在Young区域，移动到LRU头部\n        if (should_move_to_head(page)) {\n            move_to_lru_head(page);\n        }\n    } else {\n        // 在Old区域，检查是否应该提升到Young区域\n        if (page->access_time + OLD_THRESHOLD < current_time()) {\n            move_to_young_region(page);\n        }\n    }\n}\n")])])]),t("h3",{attrs:{id:"脏页刷新机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#脏页刷新机制"}},[n._v("#")]),n._v(" 脏页刷新机制")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 脏页刷新策略\nenum flush_type {\n    FLUSH_LRU,          // LRU刷新\n    FLUSH_LIST,         // 脏页链表刷新\n    FLUSH_SINGLE_PAGE,  // 单页刷新\n    FLUSH_NEIGHBOR      // 邻接页刷新\n};\n\n// 刷新触发条件\nvoid check_flush_trigger() {\n    // 1. 脏页比例超过阈值\n    if (dirty_page_ratio() > innodb_max_dirty_pages_pct) {\n        trigger_flush(FLUSH_LIST);\n    }\n    \n    // 2. Redo Log空间不足\n    if (redo_log_space_usage() > innodb_log_file_size * 0.75) {\n        trigger_flush(FLUSH_LIST);\n    }\n    \n    // 3. 空闲页不足\n    if (free_page_count() < innodb_lru_scan_depth) {\n        trigger_flush(FLUSH_LRU);\n    }\n}\n")])])]),t("h2",{attrs:{id:"崩溃恢复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#崩溃恢复"}},[n._v("#")]),n._v(" 崩溃恢复")]),n._v(" "),t("h3",{attrs:{id:"恢复流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#恢复流程"}},[n._v("#")]),n._v(" 恢复流程")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// InnoDB崩溃恢复流程\nvoid crash_recovery() {\n    // 1. 扫描Redo Log，找到最后一个Checkpoint\n    checkpoint_t* last_checkpoint = find_last_checkpoint();\n    \n    // 2. 从Checkpoint开始重做\n    lsn_t start_lsn = last_checkpoint->lsn;\n    lsn_t end_lsn = get_log_end_lsn();\n    \n    // 3. 重做阶段（Redo Phase）\n    for (lsn_t lsn = start_lsn; lsn < end_lsn; lsn++) {\n        redo_log_record_t* record = read_redo_log(lsn);\n        apply_redo_log(record);\n    }\n    \n    // 4. 回滚阶段（Undo Phase）\n    rollback_uncommitted_transactions();\n    \n    // 5. 清理阶段\n    cleanup_recovery_data();\n}\n")])])]),t("h3",{attrs:{id:"checkpoint机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#checkpoint机制"}},[n._v("#")]),n._v(" Checkpoint机制")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// Checkpoint记录结构\nstruct checkpoint {\n    uint64_t lsn;              // Checkpoint LSN\n    uint64_t offset;           // 在Redo Log中的偏移\n    uint32_t log_info;         // 日志信息\n    uint32_t checksum;         // 校验和\n};\n\n// Checkpoint触发条件\nvoid trigger_checkpoint() {\n    // 1. Redo Log空间使用超过阈值\n    if (redo_log_usage() > CHECKPOINT_THRESHOLD) {\n        perform_checkpoint();\n    }\n    \n    // 2. 定时触发\n    if (time_since_last_checkpoint() > CHECKPOINT_INTERVAL) {\n        perform_checkpoint();\n    }\n    \n    // 3. 脏页数量过多\n    if (dirty_page_count() > MAX_DIRTY_PAGES) {\n        perform_checkpoint();\n    }\n}\n")])])]),t("h2",{attrs:{id:"性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[n._v("#")]),n._v(" 性能优化")]),n._v(" "),t("h3",{attrs:{id:"配置参数优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置参数优化"}},[n._v("#")]),n._v(" 配置参数优化")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- Buffer Pool大小（建议设置为内存的70-80%）\nSET GLOBAL innodb_buffer_pool_size = 8G;\n\n-- Buffer Pool实例数（减少锁竞争）\nSET GLOBAL innodb_buffer_pool_instances = 8;\n\n-- Redo Log大小（影响恢复时间和写性能）\nSET GLOBAL innodb_log_file_size = 1G;\nSET GLOBAL innodb_log_files_in_group = 2;\n\n-- 刷盘策略\nSET GLOBAL innodb_flush_log_at_trx_commit = 1;  -- 最安全\nSET GLOBAL innodb_flush_method = O_DIRECT;      -- 避免双重缓冲\n\n-- 并发控制\nSET GLOBAL innodb_thread_concurrency = 0;      -- 不限制并发\nSET GLOBAL innodb_read_io_threads = 4;\nSET GLOBAL innodb_write_io_threads = 4;\n")])])]),t("h3",{attrs:{id:"索引优化策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#索引优化策略"}},[n._v("#")]),n._v(" 索引优化策略")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- 1. 主键选择\n-- 推荐使用自增整数作为主键\nCREATE TABLE orders (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    order_no VARCHAR(32) UNIQUE,\n    user_id INT,\n    amount DECIMAL(10,2),\n    created_at TIMESTAMP\n);\n\n-- 2. 复合索引设计\n-- 遵循最左前缀原则\nCREATE INDEX idx_user_created ON orders(user_id, created_at);\n\n-- 3. 覆盖索引\n-- 避免回表操作\nCREATE INDEX idx_user_amount ON orders(user_id, amount);\nSELECT user_id, amount FROM orders WHERE user_id = 123;\n\n-- 4. 前缀索引\n-- 对于长字符串字段\nCREATE INDEX idx_order_no_prefix ON orders(order_no(10));\n")])])]),t("h3",{attrs:{id:"查询优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查询优化"}},[n._v("#")]),n._v(" 查询优化")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- 1. 避免全表扫描\n-- 不推荐\nSELECT * FROM orders WHERE YEAR(created_at) = 2023;\n\n-- 推荐\nSELECT * FROM orders \nWHERE created_at >= '2023-01-01' AND created_at < '2024-01-01';\n\n-- 2. 合理使用LIMIT\n-- 深分页优化\nSELECT * FROM orders WHERE id > 1000000 ORDER BY id LIMIT 20;\n\n-- 3. 避免SELECT *\n-- 只查询需要的字段\nSELECT id, order_no, amount FROM orders WHERE user_id = 123;\n\n-- 4. 使用EXISTS代替IN\n-- 当子查询结果集较大时\nSELECT * FROM users u \nWHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = u.id);\n")])])]),t("h2",{attrs:{id:"监控与诊断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#监控与诊断"}},[n._v("#")]),n._v(" 监控与诊断")]),n._v(" "),t("h3",{attrs:{id:"性能监控"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能监控"}},[n._v("#")]),n._v(" 性能监控")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- 1. 查看InnoDB状态\nSHOW ENGINE INNODB STATUS;\n\n-- 2. 监控Buffer Pool\nSELECT \n    POOL_ID,\n    POOL_SIZE,\n    FREE_BUFFERS,\n    DATABASE_PAGES,\n    OLD_DATABASE_PAGES,\n    MODIFIED_DATABASE_PAGES\nFROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS;\n\n-- 3. 监控锁等待\nSELECT \n    r.trx_id waiting_trx_id,\n    r.trx_mysql_thread_id waiting_thread,\n    r.trx_query waiting_query,\n    b.trx_id blocking_trx_id,\n    b.trx_mysql_thread_id blocking_thread,\n    b.trx_query blocking_query\nFROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS w\nINNER JOIN INFORMATION_SCHEMA.INNODB_TRX b ON b.trx_id = w.blocking_trx_id\nINNER JOIN INFORMATION_SCHEMA.INNODB_TRX r ON r.trx_id = w.requesting_trx_id;\n\n-- 4. 监控Redo Log\nSHOW GLOBAL STATUS LIKE 'Innodb_log%';\n")])])]),t("h3",{attrs:{id:"慢查询分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#慢查询分析"}},[n._v("#")]),n._v(" 慢查询分析")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- 开启慢查询日志\nSET GLOBAL slow_query_log = ON;\nSET GLOBAL long_query_time = 1;\nSET GLOBAL log_queries_not_using_indexes = ON;\n\n-- 分析执行计划\nEXPLAIN FORMAT=JSON \nSELECT * FROM orders o \nJOIN users u ON o.user_id = u.id \nWHERE o.created_at > '2023-01-01';\n\n-- 查看索引使用情况\nSELECT \n    TABLE_SCHEMA,\n    TABLE_NAME,\n    INDEX_NAME,\n    SEQ_IN_INDEX,\n    COLUMN_NAME,\n    CARDINALITY\nFROM INFORMATION_SCHEMA.STATISTICS \nWHERE TABLE_SCHEMA = 'your_database'\nORDER BY TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;\n")])])]),t("h2",{attrs:{id:"实际应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实际应用场景"}},[n._v("#")]),n._v(" 实际应用场景")]),n._v(" "),t("h3",{attrs:{id:"_1-高并发oltp系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-高并发oltp系统"}},[n._v("#")]),n._v(" 1. 高并发OLTP系统")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- 订单系统表设计\nCREATE TABLE orders (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    order_no VARCHAR(32) NOT NULL UNIQUE,\n    user_id INT NOT NULL,\n    status TINYINT NOT NULL DEFAULT 0,\n    amount DECIMAL(10,2) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    \n    INDEX idx_user_status (user_id, status),\n    INDEX idx_created_at (created_at),\n    INDEX idx_status_created (status, created_at)\n) ENGINE=InnoDB;\n\n-- 优化配置\ninnodb_buffer_pool_size = 16G\ninnodb_log_file_size = 2G\ninnodb_flush_log_at_trx_commit = 2\ninnodb_thread_concurrency = 0\n")])])]),t("h3",{attrs:{id:"_2-数据仓库etl"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据仓库etl"}},[n._v("#")]),n._v(" 2. 数据仓库ETL")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("-- 批量插入优化\nSET autocommit = 0;\nSET unique_checks = 0;\nSET foreign_key_checks = 0;\n\n-- 使用LOAD DATA INFILE\nLOAD DATA INFILE '/path/to/data.csv'\nINTO TABLE staging_table\nFIELDS TERMINATED BY ','\nLINES TERMINATED BY '\\n';\n\nCOMMIT;\n\n-- 恢复设置\nSET unique_checks = 1;\nSET foreign_key_checks = 1;\nSET autocommit = 1;\n")])])]),t("h3",{attrs:{id:"_3-读写分离架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-读写分离架构"}},[n._v("#")]),n._v(" 3. 读写分离架构")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('-- 主库配置（写操作）\ninnodb_flush_log_at_trx_commit = 1  -- 保证数据安全\ninnodb_sync_binlog = 1\n\n-- 从库配置（读操作）\ninnodb_flush_log_at_trx_commit = 2  -- 提高性能\nread_only = 1\n\n-- 应用层读写分离\n// 写操作路由到主库\nwriteDataSource.execute("INSERT INTO orders ...");\n\n// 读操作路由到从库\nreadDataSource.query("SELECT * FROM orders WHERE ...");\n')])])]),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),t("p",[n._v("InnoDB作为MySQL的默认存储引擎，其强大的功能和优秀的性能源于精心设计的架构：")]),n._v(" "),t("ol",[t("li",[t("strong",[n._v("存储结构")]),n._v("：B+树索引、页式存储、聚簇索引设计")]),n._v(" "),t("li",[t("strong",[n._v("事务支持")]),n._v("：ACID特性、MVCC、Redo/Undo Log")]),n._v(" "),t("li",[t("strong",[n._v("锁机制")]),n._v("：行级锁、Next-Key Lock、死锁检测")]),n._v(" "),t("li",[t("strong",[n._v("缓冲管理")]),n._v("：Buffer Pool、改进的LRU算法")]),n._v(" "),t("li",[t("strong",[n._v("崩溃恢复")]),n._v("：WAL、Checkpoint、两阶段恢复")])]),n._v(" "),t("p",[n._v("理解InnoDB的底层原理，有助于我们：")]),n._v(" "),t("ul",[t("li",[n._v("设计高效的数据库表结构和索引")]),n._v(" "),t("li",[n._v("编写高性能的SQL查询")]),n._v(" "),t("li",[n._v("合理配置数据库参数")]),n._v(" "),t("li",[n._v("快速诊断和解决性能问题")]),n._v(" "),t("li",[n._v("构建稳定可靠的数据库应用")])]),n._v(" "),t("p",[n._v("InnoDB的设计思想和实现技术，为现代数据库系统的发展提供了重要参考，值得深入学习和研究。")])])}),[],!1,null,null,null);t.default=r.exports}}]);