(window.webpackJsonp=window.webpackJsonp||[]).push([[294],{1114:function(v,_,a){"use strict";a.r(_);var t=a(1),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("blockquote",[_("p",[v._v("点击勘误"),_("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[v._v("issues"),_("OutboundLink")],1),v._v("，哪吒感谢大家的阅读")])]),v._v(" "),_("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),v._v(" "),_("h2",{attrs:{id:"计算机操作系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算机操作系统"}},[v._v("#")]),v._v(" 计算机操作系统")]),v._v(" "),_("p",[v._v("计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中去，接下来，再取出第二条指令，在控制器的指挥下完成规定操作，依此进行下去。直至遇到停止指令")]),v._v(" "),_("h3",{attrs:{id:"计算机五大核心组成部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算机五大核心组成部分"}},[v._v("#")]),v._v(" 计算机五大核心组成部分")]),v._v(" "),_("p",[v._v("控制器：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。")]),v._v(" "),_("p",[v._v("运算器：运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进行加工处理。")]),v._v(" "),_("p",[v._v("存储器：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。")]),v._v(" "),_("p",[v._v("输入：输入设备是计算机的重要组成部分，输入设备与输出设备合你为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。")]),v._v(" "),_("p",[v._v("常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。")]),v._v(" "),_("p",[v._v("输出：输出设备与输入设备同样是计算机的重要组成部分，它把外算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来，微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。")]),v._v(" "),_("h3",{attrs:{id:"计算机结构分成以下-5-个部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算机结构分成以下-5-个部分"}},[v._v("#")]),v._v(" 计算机结构分成以下 5 个部分：")]),v._v(" "),_("p",[v._v("输入设备；输出设备；内存；中央处理器；总线。")]),v._v(" "),_("h3",{attrs:{id:"多级缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多级缓存"}},[v._v("#")]),v._v(" 多级缓存")]),v._v(" "),_("p",[v._v("现代CPU为了提升执行效率，减少CPU与内存的交互(交互影响CPU效率)，一般在CPU上集成了多级缓存架构")]),v._v(" "),_("p",[v._v("CPU缓存即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器")]),v._v(" "),_("p",[v._v("由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，减少CPU的等待时间，提高了系统的效率")]),v._v(" "),_("p",[v._v("简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。")]),v._v(" "),_("p",[v._v("CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 CPU 的指令周期。")]),v._v(" "),_("h2",{attrs:{id:"内核态和用户态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内核态和用户态"}},[v._v("#")]),v._v(" 内核态和用户态")]),v._v(" "),_("h3",{attrs:{id:"什么是用户态和内核态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是用户态和内核态"}},[v._v("#")]),v._v(" 什么是用户态和内核态")]),v._v(" "),_("p",[v._v("Kernel 运行在超级权限模式下，所以拥有很高的权限。")]),v._v(" "),_("p",[v._v("按照权限管理的原则，多数应用程序应该运行在最小权限下。")]),v._v(" "),_("p",[v._v("因此，很多操作系统，将内存分成了两个区域：")]),v._v(" "),_("h3",{attrs:{id:"内核空间-kernal-space-这个空间只有内核程序可以访问"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内核空间-kernal-space-这个空间只有内核程序可以访问"}},[v._v("#")]),v._v(" 内核空间（Kernal Space），这个空间只有内核程序可以访问；")]),v._v(" "),_("h3",{attrs:{id:"用户空间-user-space-这部分内存专门给应用程序使用。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用户空间-user-space-这部分内存专门给应用程序使用。"}},[v._v("#")]),v._v(" 用户空间（User Space），这部分内存专门给应用程序使用。")]),v._v(" "),_("p",[v._v("用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用户态 执行。")]),v._v(" "),_("p",[v._v("内核空间中的代码可以访问所有内存，我们称这些程序在内核态 执行。")]),v._v(" "),_("h3",{attrs:{id:"按照级别分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#按照级别分"}},[v._v("#")]),v._v(" 按照级别分：")]),v._v(" "),_("p",[v._v("当程序运行在0级特权级上时，就可以称之为运行在内核态")]),v._v(" "),_("p",[v._v("当程序运行在3级特权级上时，就可以称之为运行在用户态")]),v._v(" "),_("p",[v._v("运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。")]),v._v(" "),_("p",[v._v("当我们在系统中执行一个程序时，大部分时间是运行在"),_("strong",[v._v("用户态下")]),v._v("的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会"),_("strong",[v._v("切换到内核态")]),v._v("（比如操作硬件）")]),v._v(" "),_("h3",{attrs:{id:"这两种状态的主要差别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#这两种状态的主要差别"}},[v._v("#")]),v._v(" 这两种状态的主要差别")]),v._v(" "),_("p",[v._v("处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的")]),v._v(" "),_("p",[v._v("处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。")]),v._v(" "),_("h3",{attrs:{id:"为什么要有用户态和内核态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么要有用户态和内核态"}},[v._v("#")]),v._v(" 为什么要有用户态和内核态")]),v._v(" "),_("p",[v._v("由于需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络")]),v._v(" "),_("h3",{attrs:{id:"用户态与内核态的切换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用户态与内核态的切换"}},[v._v("#")]),v._v(" 用户态与内核态的切换")]),v._v(" "),_("p",[v._v("所有用户程序都是运行在用户态的，但是有时候程序确实需要做一些内核态的事情， 例如从硬盘读取数据，或者从键盘获取输入等，而唯一可以做这些事情的就是操作系统，所以此时程序就需要先操作系统请求以程序的名义来执行这些操作")]),v._v(" "),_("h3",{attrs:{id:"用户态和内核态的转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用户态和内核态的转换"}},[v._v("#")]),v._v(" 用户态和内核态的转换")]),v._v(" "),_("p",[v._v("系统调用")]),v._v(" "),_("p",[v._v("用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用")]),v._v(" "),_("p",[v._v("而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断")]),v._v(" "),_("h2",{attrs:{id:"线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[v._v("#")]),v._v(" 线程")]),v._v(" "),_("p",[v._v("线程：系统分配处理器时间资源的基本单元，是程序执行的最小单位")]),v._v(" "),_("p",[v._v("线程可以看做轻量级的进程，共享内存空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。")]),v._v(" "),_("p",[v._v("在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）")]),v._v(" "),_("p",[v._v("进程可以通过 API 创建用户态的线程，也可以通过系统调用创建内核态的线程。")]),v._v(" "),_("h3",{attrs:{id:"用户态线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用户态线程"}},[v._v("#")]),v._v(" 用户态线程")]),v._v(" "),_("p",[v._v("用户态线程也称作用户级线程，操作系统内核并不知道它的存在，它完全是在用户空间中创建。")]),v._v(" "),_("p",[v._v("用户级线程有很多优势，比如：")]),v._v(" "),_("p",[v._v("管理开销小：创建、销毁不需要系统调用。")]),v._v(" "),_("p",[v._v("切换成本低：用户空间程序可以自己维护，不需要走操作系统调度。")]),v._v(" "),_("p",[v._v("但是这种线程也有很多的缺点：")]),v._v(" "),_("p",[v._v("与内核协作成本高：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。")]),v._v(" "),_("p",[v._v("线程间协作成本高：设想两个线程需要通信，通信需要 I/O，I/O 需要系统调用，因此用户态线程需要额外的系统调用成本。")]),v._v(" "),_("p",[v._v("无法利用多核优势：比如操作系统调度的仍然是这个线程所属的进程，所以无论每次一个进程有多少用户态的线程，都只能并发执行一个线程，因此一个进程的多个线程无法利用多核的优势。")]),v._v(" "),_("p",[v._v("操作系统无法针对线程调度进行优化：当一个进程的一个用户态线程阻塞（Block）了，操作系统无法及时发现和处理阻塞问题，它不会更换执行其他线程，从而造成资源浪费。")]),v._v(" "),_("h3",{attrs:{id:"内核态线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内核态线程"}},[v._v("#")]),v._v(" 内核态线程")]),v._v(" "),_("p",[v._v("内核态线程也称作内核级线程（Kernel Level Thread），这种线程执行在内核态，可以通过系统调用创造一个内核级线程。")]),v._v(" "),_("p",[v._v("内核级线程有很多优势：")]),v._v(" "),_("p",[v._v("可以利用多核 CPU 优势：内核拥有较高权限，因此可以在多个 CPU 核心上执行内核线程。")]),v._v(" "),_("p",[v._v("操作系统级优化：内核中的线程操作 I/O 不需要进行系统调用；一个内核线程阻塞了，可以立即让另一个执行。")]),v._v(" "),_("p",[v._v("当然内核线程也有一些缺点：")]),v._v(" "),_("p",[v._v("创建成本高："),_("strong",[v._v("创建的时候需要系统调用")]),v._v("，"),_("strong",[v._v("也就是切换到内核态")]),v._v("。")]),v._v(" "),_("p",[v._v("扩展性差："),_("strong",[v._v("由一个内核程序管理")]),v._v("，"),_("strong",[v._v("不可能数量太多")]),v._v("。")]),v._v(" "),_("p",[v._v("切换成本较高："),_("strong",[v._v("切换的时候")]),v._v("，"),_("strong",[v._v("也同样存在需要内核操作")]),v._v("，"),_("strong",[v._v("需要切换内核态")]),v._v("。")]),v._v(" "),_("p",[v._v("用户态线程和内核态线程之间的映射关系")]),v._v(" "),_("p",[v._v("如果有一个用户态的进程，它下面有多个线程，如果这个进程想要执行下面的某一个线程，应该如何做呢？")]),v._v(" "),_("p",[v._v("这时，比较常见的一种方式，就是将需要执行的程序，让一个内核线程去执行。")]),v._v(" "),_("p",[v._v("毕竟，"),_("strong",[v._v("内核线程是真正的线程，因为它会分配到 CPU 的执行资源")]),v._v("。")]),v._v(" "),_("p",[v._v("如果一个进程所有的线程都要自己调度，相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。")]),v._v(" "),_("p",[v._v("这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。")]),v._v(" "),_("p",[v._v("这样操作劣势非常明显，比如无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。")]),v._v(" "),_("p",[v._v("由此可见，"),_("strong",[v._v("用户态线程创建成本低，问题明显，不可以利用多核")]),v._v("。")]),v._v(" "),_("p",[v._v("内核态线程，"),_("strong",[v._v("创建成本高，可以利用多核，切换速度慢")]),v._v("。")]),v._v(" "),_("p",[v._v("因此通常我们会在内核中预先创建一些线程，并反复利用这些线程。")]),v._v(" "),_("h2",{attrs:{id:"协程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协程"}},[v._v("#")]),v._v(" 协程")]),v._v(" "),_("p",[_("strong",[v._v("协程")]),v._v("，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。")]),v._v(" "),_("p",[v._v("这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。")]),v._v(" "),_("h3",{attrs:{id:"子程序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#子程序"}},[v._v("#")]),v._v(" 子程序")]),v._v(" "),_("p",[v._v("或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。")]),v._v(" "),_("p",[v._v("所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。")]),v._v(" "),_("p",[v._v("子程序调用总是一个入口，一次返回，调用顺序是明确的。")]),v._v(" "),_("p",[v._v("协程的特点在于是一个线程执行，那和多线程比，协程有何优势？")]),v._v(" "),_("p",[v._v("极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；")]),v._v(" "),_("p",[v._v("不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。")]),v._v(" "),_("h3",{attrs:{id:"线程安全"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程安全"}},[v._v("#")]),v._v(" 线程安全")]),v._v(" "),_("p",[v._v("如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。")]),v._v(" "),_("p",[v._v("如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。")]),v._v(" "),_("h2",{attrs:{id:"进程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[v._v("#")]),v._v(" 进程")]),v._v(" "),_("p",[v._v("在系统中正在运行的一个应用程序；程序一旦运行就是进程；是资源分配的最小单位。")]),v._v(" "),_("p",[v._v("在操作系统中能同时运行多个进程；")]),v._v(" "),_("p",[v._v("开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。")]),v._v(" "),_("p",[v._v("进程可以分成用户态进程和内核态进程两类，用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。")]),v._v(" "),_("p",[v._v("如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。")]),v._v(" "),_("p",[v._v("每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换会有较大的开销；")]),v._v(" "),_("h2",{attrs:{id:"分时和调度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分时和调度"}},[v._v("#")]),v._v(" 分时和调度")]),v._v(" "),_("p",[v._v("每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。")]),v._v(" "),_("p",[v._v("注意，现代操作系统都是直接调度线程，不会调度进程。")]),v._v(" "),_("h2",{attrs:{id:"分配时间片段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分配时间片段"}},[v._v("#")]),v._v(" 分配时间片段")]),v._v(" "),_("p",[v._v("进程 1 需要 2 个时间片段，进程 2 只有 1 个时间片段，进程 3 需要 3 个时间片段。")]),v._v(" "),_("p",[v._v("因此当进程 1 执行到一半时，会先挂起，然后进程 2 开始执行；进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始，这个就是分时技术。")]),v._v(" "),_("h2",{attrs:{id:"进程间通信ipc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程间通信ipc"}},[v._v("#")]),v._v(" 进程间通信IPC")]),v._v(" "),_("p",[v._v("每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信")]),v._v(" "),_("h3",{attrs:{id:"管道-匿名管道"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#管道-匿名管道"}},[v._v("#")]),v._v(" 管道/匿名管道")]),v._v(" "),_("p",[v._v("管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。")]),v._v(" "),_("p",[v._v("只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);")]),v._v(" "),_("p",[v._v("单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。")]),v._v(" "),_("p",[v._v("数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出，写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。")]),v._v(" "),_("h3",{attrs:{id:"有名管道-fifo"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有名管道-fifo"}},[v._v("#")]),v._v(" 有名管道(FIFO)")]),v._v(" "),_("p",[v._v("匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。")]),v._v(" "),_("p",[v._v("为了克服这个缺点，提出了有名管道(FIFO)。")]),v._v(" "),_("p",[v._v("有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。")]),v._v(" "),_("h3",{attrs:{id:"信号"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#信号"}},[v._v("#")]),v._v(" 信号")]),v._v(" "),_("p",[v._v("信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。")]),v._v(" "),_("p",[v._v("如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。")]),v._v(" "),_("p",[v._v("如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。")]),v._v(" "),_("h3",{attrs:{id:"消息队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[v._v("#")]),v._v(" 消息队列")]),v._v(" "),_("p",[v._v("消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。")]),v._v(" "),_("p",[v._v("与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。")]),v._v(" "),_("p",[v._v("另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达")]),v._v(" "),_("h3",{attrs:{id:"共享内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#共享内存"}},[v._v("#")]),v._v(" 共享内存")]),v._v(" "),_("p",[v._v("使得多个进程可以直接读写同一块内存空间，是最快的可用IPC形式，是针对其他通信机制运行效率较低而设计的。")]),v._v(" "),_("p",[v._v("为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间，进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。")]),v._v(" "),_("p",[v._v("由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。")]),v._v(" "),_("h2",{attrs:{id:"守护进程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#守护进程"}},[v._v("#")]),v._v(" 守护进程")]),v._v(" "),_("p",[v._v("守护进程是脱离于终端并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示，并且进程也不会被任何终端所产生的终端信息所打断。")]),v._v(" "),_("p",[v._v("守护进程一般的生命周期是系统启动到系统停止运行。")]),v._v(" "),_("p",[v._v("Linux系统中有很多的守护进程，最典型的就是我们经常看到的服务进程。")]),v._v(" "),_("p",[v._v("当然，我们也经常会利用守护进程来完成很多的系统或者自动化任务。")]),v._v(" "),_("h3",{attrs:{id:"孤儿进程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#孤儿进程"}},[v._v("#")]),v._v(" 孤儿进程")]),v._v(" "),_("p",[v._v("父进程早于子进程退出时候子进程还在运行，子进程会成为孤儿进程，Linux会对孤儿进程的处理，把孤儿进程的父进程设为进程号为1的进程，也就是由init进程来托管，init进程负责子进程退出后的善后清理工作")]),v._v(" "),_("h3",{attrs:{id:"僵尸进程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#僵尸进程"}},[v._v("#")]),v._v(" 僵尸进程")]),v._v(" "),_("p",[v._v("子进程执行完毕时发现父进程未退出，会向父进程发送 SIGCHLD 信号，但父进程没有使用 wait/waitpid 或其他方式处理 SIGCHLD 信号来回收子进程，子进程变成为了对系统有害的僵尸进程")]),v._v(" "),_("p",[v._v("子进程退出后留下的进程信息没有被收集，会导致占用的进程控制块PCB不被释放，形成僵尸进程，进程已经死去，但是进程资源没有被释放掉")]),v._v(" "),_("h3",{attrs:{id:"问题及危害"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#问题及危害"}},[v._v("#")]),v._v(" 问题及危害")]),v._v(" "),_("p",[v._v("如果系统中存在大量的僵尸进程，他们的进程号就会一直被占用，但是系统所能使用的进程号是有限的，系统将因为没有可用的进程号而导致系统不能产生新的进程")]),v._v(" "),_("p",[v._v("任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理，这是每个子进程在结束时都要经过的阶段，如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是Z。")]),v._v(" "),_("p",[v._v("如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态")]),v._v(" "),_("p",[v._v("产生僵尸进程的元凶其实是他们的父进程，杀掉父进程，僵尸进程就变为了孤儿进程，便可以转交给 init 进程回收处理")]),v._v(" "),_("h3",{attrs:{id:"死锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[v._v("#")]),v._v(" 死锁")]),v._v(" "),_("p",[v._v("产生原因")]),v._v(" "),_("p",[v._v("系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。")]),v._v(" "),_("p",[v._v("进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。")]),v._v(" "),_("h3",{attrs:{id:"发生死锁的四个必要条件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#发生死锁的四个必要条件"}},[v._v("#")]),v._v(" 发生死锁的四个必要条件")]),v._v(" "),_("p",[v._v("互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待")]),v._v(" "),_("p",[v._v("请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求时，该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放")]),v._v(" "),_("p",[v._v("不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)")]),v._v(" "),_("p",[v._v("循环等待条件: 若干进程间形成首尾相接循环等待资源的关系")]),v._v(" "),_("p",[v._v("这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁")]),v._v(" "),_("p",[v._v("只要我们破坏其中一个，就可以成功避免死锁的发生")]),v._v(" "),_("p",[v._v("其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥")]),v._v(" "),_("p",[v._v("对于占用且等待这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。")]),v._v(" "),_("p",[v._v("对于不可抢占这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。")]),v._v(" "),_("p",[v._v("对于循环等待这个条件，可以靠按序申请资源来预防，所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。")]),v._v(" "),_("h3",{attrs:{id:"处理方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#处理方法"}},[v._v("#")]),v._v(" 处理方法")]),v._v(" "),_("p",[v._v("主要有以下四种方法：")]),v._v(" "),_("ul",[_("li",[v._v("鸵鸟策略")]),v._v(" "),_("li",[v._v("死锁检测与死锁恢复")]),v._v(" "),_("li",[v._v("死锁预防，破坏4个必要条件")]),v._v(" "),_("li",[v._v("死锁避免，银行家算法")]),v._v(" "),_("li",[v._v("鸵鸟策略")])]),v._v(" "),_("p",[v._v("把头埋在沙子里，假装根本没发生问题。")]),v._v(" "),_("p",[v._v("因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。")]),v._v(" "),_("p",[v._v("当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。")]),v._v(" "),_("h3",{attrs:{id:"死锁检测"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死锁检测"}},[v._v("#")]),v._v(" 死锁检测")]),v._v(" "),_("p",[v._v("不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。")]),v._v(" "),_("p",[v._v("每种类型一个资源的死锁检测")]),v._v(" "),_("p",[v._v("每种类型多个资源的死锁检测")]),v._v(" "),_("h3",{attrs:{id:"死锁恢复"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死锁恢复"}},[v._v("#")]),v._v(" 死锁恢复")]),v._v(" "),_("ul",[_("li",[v._v("利用抢占恢复")]),v._v(" "),_("li",[v._v("利用回滚恢复")]),v._v(" "),_("li",[v._v("通过杀死进程恢复")])]),v._v(" "),_("p",[v._v("哲学家进餐问题")]),v._v(" "),_("p",[v._v("五个哲学家围着一张圆桌，每个哲学家面前放着食物。")]),v._v(" "),_("p",[v._v("哲学家的生活有两种交替活动：吃饭以及思考。")]),v._v(" "),_("p",[v._v("当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。")]),v._v(" "),_("p",[v._v("如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。")]),v._v(" "),_("p",[v._v("哲学家进餐问题可看作是并发进程并发执行时处理共享资源的一个有代表性的问题。")]),v._v(" "),_("p",[v._v("为了防止死锁的发生，可以设置两个条件：")]),v._v(" "),_("p",[v._v("必须同时拿起左右两根筷子；")]),v._v(" "),_("p",[v._v("只有在两个邻居都没有进餐的情况下才允许进餐。")]),v._v(" "),_("h3",{attrs:{id:"银行家算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#银行家算法"}},[v._v("#")]),v._v(" 银行家算法")]),v._v(" "),_("p",[v._v("银行家算法的命名是它可以用了银行系统，当不能满足所有客户的需求时，银行绝不会分配其资金。")]),v._v(" "),_("p",[v._v("当新进程进入系统时，它必须说明其可能需要的每种类型资源实例的最大数量这一数量不可以超过系统资源的总和。")]),v._v(" "),_("p",[v._v("当用户申请一组资源时，系统必须确定这些资源的分配是否处于安全状态，如何安全，则分配，如果不安全，那么进程必须等待指导某个其他进程释放足够资源为止。")]),v._v(" "),_("h3",{attrs:{id:"安全状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#安全状态"}},[v._v("#")]),v._v(" 安全状态")]),v._v(" "),_("p",[v._v("在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性，若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，令进程等待")]),v._v(" "),_("p",[v._v("因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态")]),v._v(" "),_("h3",{attrs:{id:"fork函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#fork函数"}},[v._v("#")]),v._v(" Fork函数")]),v._v(" "),_("p",[v._v("fork函数用于创建一个与当前进程一样的子进程，所创建的子进程将复制父进程的代码段、数据段、BSS段、堆、栈等所有用户空间信息，在内核中操作系统会重新为其申请一个子进程执行的位置。")]),v._v(" "),_("p",[v._v("fork系统调用会通过复制一个现有进程来创建一个全新的进程，新进程被存放在一个叫做任务队列的双向循环链表中，链表中的每一项都是类型为task_struct的进程控制块PCB的结构。")]),v._v(" "),_("h2",{attrs:{id:"进程、线程的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程、线程的区别"}},[v._v("#")]),v._v(" 进程、线程的区别")]),v._v(" "),_("p",[v._v("操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。")]),v._v(" "),_("p",[v._v("调度：线程作为CPU调度和分配的基本单位，进程作为拥有资源的基本单位；")]),v._v(" "),_("p",[v._v("并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；")]),v._v(" "),_("p",[v._v("拥有资源：")]),v._v(" "),_("p",[v._v("进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。")]),v._v(" "),_("p",[v._v("进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；")]),v._v(" "),_("p",[v._v("线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；")]),v._v(" "),_("h2",{attrs:{id:"系统开销"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统开销"}},[v._v("#")]),v._v(" 系统开销：")]),v._v(" "),_("p",[v._v("在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。")]),v._v(" "),_("p",[v._v("但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。")]),v._v(" "),_("p",[v._v("线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。")]),v._v(" "),_("h2",{attrs:{id:"一个进程可以创建多少线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一个进程可以创建多少线程"}},[v._v("#")]),v._v(" 一个进程可以创建多少线程")]),v._v(" "),_("p",[v._v("理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。")]),v._v(" "),_("p",[v._v("如果要创建多于2048的话，必须修改编译器的设置。")]),v._v(" "),_("p",[v._v("在一般情况下，你不需要那么多的线程，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。")]),v._v(" "),_("h2",{attrs:{id:"外中断和异常有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#外中断和异常有什么区别"}},[v._v("#")]),v._v(" 外中断和异常有什么区别")]),v._v(" "),_("p",[v._v("外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求，此外还有时钟中断、控制台中断等。")]),v._v(" "),_("p",[v._v("而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。")]),v._v(" "),_("h2",{attrs:{id:"解决hash冲突四种方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决hash冲突四种方法"}},[v._v("#")]),v._v(" 解决Hash冲突四种方法")]),v._v(" "),_("p",[v._v("开放定址法")]),v._v(" "),_("p",[v._v("开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。")]),v._v(" "),_("p",[v._v("链地址法")]),v._v(" "),_("p",[v._v("将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。")]),v._v(" "),_("p",[v._v("再哈希法")]),v._v(" "),_("p",[v._v("当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。")]),v._v(" "),_("p",[v._v("建立公共溢出区")]),v._v(" "),_("p",[v._v("将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。")]),v._v(" "),_("h2",{attrs:{id:"分页机制和分段机制有哪些共同点和区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分页机制和分段机制有哪些共同点和区别"}},[v._v("#")]),v._v(" 分页机制和分段机制有哪些共同点和区别")]),v._v(" "),_("p",[v._v("共同点")]),v._v(" "),_("ul",[_("li",[v._v("分页机制和分段机制都是为了提高内存利用率，较少内存碎片。")]),v._v(" "),_("li",[v._v("页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。")])]),v._v(" "),_("p",[v._v("区别")]),v._v(" "),_("ul",[_("li",[v._v("页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。")]),v._v(" "),_("li",[v._v("分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。")]),v._v(" "),_("li",[v._v("分页是一维地址空间，分段是二维的。")])]),v._v(" "),_("h2",{attrs:{id:"介绍一下几种典型的锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下几种典型的锁"}},[v._v("#")]),v._v(" 介绍一下几种典型的锁")]),v._v(" "),_("h2",{attrs:{id:"读写锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#读写锁"}},[v._v("#")]),v._v(" 读写锁")]),v._v(" "),_("p",[v._v("可以同时进行多个读")]),v._v(" "),_("p",[v._v("写者必须互斥（只允许一个写者写，也不能读者写者同时进行）")]),v._v(" "),_("p",[v._v("写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）")]),v._v(" "),_("h2",{attrs:{id:"互斥锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁"}},[v._v("#")]),v._v(" 互斥锁")]),v._v(" "),_("p",[v._v("一次只能一个线程拥有互斥锁，其他线程只有等待")]),v._v(" "),_("p",[v._v("互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。")]),v._v(" "),_("p",[v._v("互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁")]),v._v(" "),_("h2",{attrs:{id:"条件变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#条件变量"}},[v._v("#")]),v._v(" 条件变量")]),v._v(" "),_("p",[v._v("互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。")]),v._v(" "),_("p",[v._v("而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。")]),v._v(" "),_("p",[v._v("当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。")]),v._v(" "),_("p",[v._v("一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。")]),v._v(" "),_("p",[v._v("总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。")]),v._v(" "),_("h2",{attrs:{id:"自旋锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁"}},[v._v("#")]),v._v(" 自旋锁")]),v._v(" "),_("p",[v._v("如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。")]),v._v(" "),_("p",[v._v("如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。")]),v._v(" "),_("p",[v._v("虽然它的效率比互斥锁高，但是它也有些不足之处：")]),v._v(" "),_("p",[v._v("自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。")]),v._v(" "),_("p",[v._v("在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。")]),v._v(" "),_("h2",{attrs:{id:"虚拟内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存"}},[v._v("#")]),v._v(" 虚拟内存")]),v._v(" "),_("p",[v._v("很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存")]),v._v(" "),_("p",[v._v("通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间。")]),v._v(" "),_("p",[v._v("另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。")]),v._v(" "),_("p",[v._v("虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存")]),v._v(" "),_("p",[v._v("虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间")])])}),[],!1,null,null,null);_.default=s.exports}}]);