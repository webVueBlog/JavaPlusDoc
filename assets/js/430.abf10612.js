(window.webpackJsonp=window.webpackJsonp||[]).push([[430],{1263:function(s,t,a){"use strict";a.r(t);var _=a(1),v=Object(_.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("blockquote",[t("p",[s._v("点击勘误"),t("a",{attrs:{href:"https://github.com/webVueBlog/JavaPlusDoc/issues",target:"_blank",rel:"noopener noreferrer"}},[s._v("issues"),t("OutboundLink")],1),s._v("，哪吒感谢大家的阅读")])]),s._v(" "),t("img",{attrs:{align:"right",width:"100",src:"https://cdn.jsdelivr.net/gh/YunYouJun/yun/images/yun-alpha-compressed.png"}}),s._v(" "),t("h2",{attrs:{id:"mysql锁机制详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql锁机制详解"}},[s._v("#")]),s._v(" MySQL锁机制详解")]),s._v(" "),t("p",[s._v("MySQL 中的锁是数据库并发控制的基本机制，用于管理对共享资源的并发访问，确保数据的一致性和完整性。本文将详细介绍 MySQL 中的各种锁类型、工作原理、使用场景以及最佳实践。")]),s._v(" "),t("h2",{attrs:{id:"锁的基本概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁的基本概念"}},[s._v("#")]),s._v(" 锁的基本概念")]),s._v(" "),t("p",[s._v("锁是一种并发控制机制，用于协调多个事务对共享资源的访问。在数据库系统中，锁的主要目的是保证数据的一致性和完整性，防止并发操作导致的数据异常。")]),s._v(" "),t("p",[s._v("锁的基本特性包括：")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("互斥性")]),s._v("：某些锁（如排他锁）一旦被获取，其他事务就无法再获取相同的锁")]),s._v(" "),t("li",[t("strong",[s._v("共享性")]),s._v("：某些锁（如共享锁）允许多个事务同时持有")]),s._v(" "),t("li",[t("strong",[s._v("粒度")]),s._v("：锁可以作用于不同级别的数据库对象（如行、页、表）")]),s._v(" "),t("li",[t("strong",[s._v("持续时间")]),s._v("：锁的持有时间可以是短暂的（如语句级），也可以是长期的（如事务级）")])]),s._v(" "),t("h2",{attrs:{id:"按操作类型分类的锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#按操作类型分类的锁"}},[s._v("#")]),s._v(" 按操作类型分类的锁")]),s._v(" "),t("h3",{attrs:{id:"读锁-共享锁-s锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#读锁-共享锁-s锁"}},[s._v("#")]),s._v(" 读锁（共享锁/S锁）")]),s._v(" "),t("p",[s._v("读锁，也称为共享锁（Shared Lock）或 S 锁，是一种允许多个事务同时读取同一资源，但阻止其他事务获取写锁的锁类型。")]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("允许多个事务同时获取同一资源的读锁")]),s._v(" "),t("li",[s._v("持有读锁的事务只能读取资源，不能修改")]),s._v(" "),t("li",[s._v("如果一个资源已经被加了读锁，其他事务可以继续加读锁，但不能加写锁")])]),s._v(" "),t("p",[t("strong",[s._v("使用场景")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("查询操作，如 SELECT 语句")]),s._v(" "),t("li",[s._v("需要保证读取数据一致性的场景")])]),s._v(" "),t("p",[t("strong",[s._v("语法")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 在 SELECT 语句中显式添加共享锁")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" table_name "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" condition "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LOCK")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("IN")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHARE")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("MODE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- MySQL 8.0 新语法")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" table_name "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" condition "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FOR")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHARE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("h3",{attrs:{id:"写锁-排它锁-独占锁-x锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写锁-排它锁-独占锁-x锁"}},[s._v("#")]),s._v(" 写锁（排它锁/独占锁/X锁）")]),s._v(" "),t("p",[s._v("写锁，也称为排它锁（Exclusive Lock）、独占锁或 X 锁，是一种在事务修改数据时使用的锁，它排斥任何其他锁。")]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("一个资源只能被一个事务加写锁")]),s._v(" "),t("li",[s._v("持有写锁的事务可以读取和修改资源")]),s._v(" "),t("li",[s._v("如果一个资源已经被加了写锁，其他事务不能加读锁或写锁")]),s._v(" "),t("li",[s._v("如果一个资源已经被加了读锁，事务不能加写锁")])]),s._v(" "),t("p",[t("strong",[s._v("使用场景")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("数据修改操作，如 INSERT、UPDATE、DELETE 语句")]),s._v(" "),t("li",[s._v("需要保证数据修改原子性的场景")])]),s._v(" "),t("p",[t("strong",[s._v("语法")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 在 SELECT 语句中显式添加排它锁")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" table_name "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" condition "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FOR")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UPDATE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 修改语句会自动加排它锁")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UPDATE")]),s._v(" table_name "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SET")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("column")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("value")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" condition"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("DELETE")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" table_name "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" condition"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("h2",{attrs:{id:"按锁粒度分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#按锁粒度分类"}},[s._v("#")]),s._v(" 按锁粒度分类")]),s._v(" "),t("h3",{attrs:{id:"表锁-table-lock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#表锁-table-lock"}},[s._v("#")]),s._v(" 表锁（Table Lock）")]),s._v(" "),t("p",[s._v("表锁是 MySQL 中粒度最大的锁，它锁定整个表。")]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("开销小，加锁快，不会出现死锁")]),s._v(" "),t("li",[s._v("锁定粒度大，发生锁冲突的概率高，并发度低")]),s._v(" "),t("li",[s._v("对整表进行写操作会阻塞其他事务对该表的所有读写操作")])]),s._v(" "),t("p",[t("strong",[s._v("使用场景")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("对整表数据进行修改的场景")]),s._v(" "),t("li",[s._v("表数据量较小，并发访问不多的场景")]),s._v(" "),t("li",[s._v("MyISAM 存储引擎（只支持表级锁）")])]),s._v(" "),t("p",[t("strong",[s._v("语法")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 手动加表级读锁")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LOCK")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLES")]),s._v(" table_name "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("READ")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 手动加表级写锁")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LOCK")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLES")]),s._v(" table_name "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WRITE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 释放所有表锁")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UNLOCK")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLES")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("h3",{attrs:{id:"页锁-page-lock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#页锁-page-lock"}},[s._v("#")]),s._v(" 页锁（Page Lock）")]),s._v(" "),t("p",[s._v("页锁是介于表锁和行锁之间的一种锁，它锁定数据库中的一个页（通常是 16KB）。")]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("锁定粒度介于表锁和行锁之间")]),s._v(" "),t("li",[s._v("加锁开销和加锁时间介于表锁和行锁之间")]),s._v(" "),t("li",[s._v("会出现死锁")]),s._v(" "),t("li",[s._v("锁定粒度较大，有可能在锁定一行数据时，实际锁定了多行数据（因为它们在同一页中）")])]),s._v(" "),t("p",[t("strong",[s._v("使用场景")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("BDB 存储引擎（MySQL 5.1 后不再支持）")])]),s._v(" "),t("h3",{attrs:{id:"行锁-row-lock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行锁-row-lock"}},[s._v("#")]),s._v(" 行锁（Row Lock）")]),s._v(" "),t("p",[s._v("行锁是 MySQL 中粒度最小的锁，它只锁定表中的某一行。")]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("开销大，加锁慢，会出现死锁")]),s._v(" "),t("li",[s._v("锁定粒度小，发生锁冲突的概率低，并发度高")]),s._v(" "),t("li",[s._v("只有在访问行级数据时才会加锁")])]),s._v(" "),t("p",[t("strong",[s._v("使用场景")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("高并发系统")]),s._v(" "),t("li",[s._v("InnoDB 存储引擎（支持行级锁）")])]),s._v(" "),t("p",[t("strong",[s._v("注意")]),s._v("：InnoDB 的行锁是通过索引实现的，如果查询条件没有使用索引，InnoDB 会使用表锁。")]),s._v(" "),t("h2",{attrs:{id:"特殊类型的锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特殊类型的锁"}},[s._v("#")]),s._v(" 特殊类型的锁")]),s._v(" "),t("h3",{attrs:{id:"意向锁-intention-lock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#意向锁-intention-lock"}},[s._v("#")]),s._v(" 意向锁（Intention Lock）")]),s._v(" "),t("p",[s._v("意向锁是 InnoDB 存储引擎中的一种表级锁，用于指示事务稍后要对表中的行加什么类型的锁（共享锁或排它锁）。")]),s._v(" "),t("p",[t("strong",[s._v("类型")]),s._v("：")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("意向共享锁（IS锁）")]),s._v("：表示事务打算给表中的某些行加共享锁")]),s._v(" "),t("li",[t("strong",[s._v("意向排它锁（IX锁）")]),s._v("：表示事务打算给表中的某些行加排它锁")])]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("意向锁是表级锁，不会与行级的共享/排它锁冲突")]),s._v(" "),t("li",[s._v("意向锁之间不会互斥（IS与IS、IS与IX、IX与IX都可以共存）")]),s._v(" "),t("li",[s._v("意向锁可以与表级共享锁/排它锁互斥（IX与S、IX与X、IS与X互斥，但IS与S兼容）")])]),s._v(" "),t("p",[t("strong",[s._v("作用")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("提高加锁效率，避免在给行加锁前，需要检查表中每一行是否已经被锁定")]),s._v(" "),t("li",[s._v("实现多粒度锁定，允许行锁和表锁共存")])]),s._v(" "),t("h3",{attrs:{id:"间隙锁-gap-lock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#间隙锁-gap-lock"}},[s._v("#")]),s._v(" 间隙锁（Gap Lock）")]),s._v(" "),t("p",[s._v("间隙锁是 InnoDB 在 REPEATABLE READ 隔离级别下，为了防止幻读而引入的一种锁机制，它锁定索引记录之间的间隙。")]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("锁定索引记录之间的间隙，防止其他事务在间隙中插入数据")]),s._v(" "),t("li",[s._v("只在 REPEATABLE READ 隔离级别下生效")]),s._v(" "),t("li",[s._v("可能导致死锁和阻塞")])]),s._v(" "),t("p",[t("strong",[s._v("使用场景")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("防止幻读")]),s._v(" "),t("li",[s._v("保证事务隔离性")])]),s._v(" "),t("h3",{attrs:{id:"临键锁-next-key-lock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#临键锁-next-key-lock"}},[s._v("#")]),s._v(" 临键锁（Next-Key Lock）")]),s._v(" "),t("p",[s._v("临键锁是 InnoDB 的默认行锁算法，它是记录锁（行锁）和间隙锁的组合，锁定一个索引记录及其之前的间隙。")]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("锁定索引记录本身和索引记录之前的间隙")]),s._v(" "),t("li",[s._v("是 InnoDB 在 REPEATABLE READ 隔离级别下使用的默认锁")]),s._v(" "),t("li",[s._v("可以防止幻读")])]),s._v(" "),t("h3",{attrs:{id:"插入意向锁-insert-intention-lock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#插入意向锁-insert-intention-lock"}},[s._v("#")]),s._v(" 插入意向锁（Insert Intention Lock）")]),s._v(" "),t("p",[s._v("插入意向锁是一种特殊的间隙锁，表示插入的意图，当多个事务插入同一个索引间隙的不同位置时，不需要等待其他事务完成。")]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("是一种特殊的间隙锁")]),s._v(" "),t("li",[s._v("多个事务可以同时获取同一个间隙的插入意向锁，只要它们插入的位置不冲突")]),s._v(" "),t("li",[s._v("如果间隙已经被加了间隙锁，插入意向锁会被阻塞")])]),s._v(" "),t("p",[t("strong",[s._v("使用场景")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("提高并发插入性能")])]),s._v(" "),t("h3",{attrs:{id:"自增锁-auto-increment-lock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自增锁-auto-increment-lock"}},[s._v("#")]),s._v(" 自增锁（Auto-increment Lock）")]),s._v(" "),t("p",[s._v("自增锁是一种特殊的表级锁，用于处理 AUTO_INCREMENT 列的值生成。")]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("在插入操作中，InnoDB 会获取自增锁，确保生成的自增值是连续的")]),s._v(" "),t("li",[s._v("自增锁是一种轻量级锁，在插入语句结束后立即释放")])]),s._v(" "),t("p",[t("strong",[s._v("配置参数")]),s._v("：")]),s._v(" "),t("ul",[t("li",[t("code",[s._v("innodb_autoinc_lock_mode")]),s._v("：控制自增锁的行为\n"),t("ul",[t("li",[s._v("0：传统模式，语句级锁定")]),s._v(" "),t("li",[s._v("1：连续模式，批量插入使用表锁，单行插入使用轻量级锁")]),s._v(" "),t("li",[s._v("2：交错模式，所有插入都使用轻量级锁，但自增值可能不连续")])])])]),s._v(" "),t("h3",{attrs:{id:"元数据锁-mdl锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元数据锁-mdl锁"}},[s._v("#")]),s._v(" 元数据锁（MDL锁）")]),s._v(" "),t("p",[s._v("元数据锁（Metadata Lock）用于保护数据库对象的元数据，防止在使用对象时被其他会话修改对象结构。")]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("当对表执行 CRUD 操作时，会自动加 MDL 读锁")]),s._v(" "),t("li",[s._v("当对表结构进行变更时，会自动加 MDL 写锁")]),s._v(" "),t("li",[s._v("MDL 锁在事务提交后才会释放")])]),s._v(" "),t("p",[t("strong",[s._v("使用场景")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("防止在查询过程中表结构被修改")]),s._v(" "),t("li",[s._v("防止在修改表结构时表被查询或修改")])]),s._v(" "),t("h3",{attrs:{id:"记录锁-record-lock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#记录锁-record-lock"}},[s._v("#")]),s._v(" 记录锁（Record Lock）")]),s._v(" "),t("p",[s._v("记录锁是最简单的行锁，它锁定索引记录本身。")]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("锁定单个索引记录")]),s._v(" "),t("li",[s._v("防止其他事务修改或删除该记录")])]),s._v(" "),t("p",[t("strong",[s._v("使用场景")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("更新或删除单条记录")])]),s._v(" "),t("h2",{attrs:{id:"按实现机制分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#按实现机制分类"}},[s._v("#")]),s._v(" 按实现机制分类")]),s._v(" "),t("h3",{attrs:{id:"悲观锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁"}},[s._v("#")]),s._v(" 悲观锁")]),s._v(" "),t("p",[s._v("悲观锁是一种假设会发生并发冲突的锁机制，它在操作数据前先获取锁，确保在操作过程中数据不会被其他事务修改。")]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("先获取锁，再操作数据")]),s._v(" "),t("li",[s._v("适用于写多读少的场景")]),s._v(" "),t("li",[s._v("实现简单，但并发性能较低")])]),s._v(" "),t("p",[t("strong",[s._v("实现方式")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("使用 SELECT ... FOR UPDATE 语句")]),s._v(" "),t("li",[s._v("使用 LOCK IN SHARE MODE 语句")])]),s._v(" "),t("p",[t("strong",[s._v("示例")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 使用悲观锁更新数据")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("BEGIN")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 先锁定要更新的行")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" accounts "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" id "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FOR")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UPDATE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 执行更新操作")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UPDATE")]),s._v(" accounts "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SET")]),s._v(" balance "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" balance "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" id "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("COMMIT")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("h3",{attrs:{id:"乐观锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁"}},[s._v("#")]),s._v(" 乐观锁")]),s._v(" "),t("p",[s._v("乐观锁是一种假设不会发生并发冲突的锁机制，它在操作数据时不加锁，而是在提交更新时检查数据是否被其他事务修改过。")]),s._v(" "),t("p",[t("strong",[s._v("特点")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("不加锁，只在提交时检查冲突")]),s._v(" "),t("li",[s._v("适用于读多写少的场景")]),s._v(" "),t("li",[s._v("并发性能高，但实现复杂")])]),s._v(" "),t("p",[t("strong",[s._v("实现方式")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("使用版本号")]),s._v(" "),t("li",[s._v("使用时间戳")]),s._v(" "),t("li",[s._v("使用条件更新")])]),s._v(" "),t("p",[t("strong",[s._v("示例")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 使用版本号实现乐观锁")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 1. 查询当前数据和版本号")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" balance"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" version "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" accounts "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" id "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 2. 在应用层计算新的余额")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 3. 更新数据，同时检查版本号是否变化")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UPDATE")]),s._v(" accounts "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SET")]),s._v(" balance "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" new_balance"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" version "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" version "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" \n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" id "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("AND")]),s._v(" version "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" old_version"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 4. 检查影响的行数，如果为0表示更新失败（版本已变化）")]),s._v("\n")])])]),t("h2",{attrs:{id:"其他特殊锁类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他特殊锁类型"}},[s._v("#")]),s._v(" 其他特殊锁类型")]),s._v(" "),t("h3",{attrs:{id:"全局锁-global-lock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局锁-global-lock"}},[s._v("#")]),s._v(" 全局锁（Global Lock）")]),s._v(" "),t("p",[s._v("全局锁是 MySQL 中粒度最大的锁，它对整个数据库实例加锁，使整个数据库处于只读状态。")]),s._v(" "),t("p",[t("strong",[s._v("使用场景")]),s._v("：")]),s._v(" "),t("ul",[t("li",[s._v("全库备份")])]),s._v(" "),t("p",[t("strong",[s._v("语法")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 加全局锁")]),s._v("\nFLUSH "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLES")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WITH")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("READ")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LOCK")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 释放全局锁")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UNLOCK")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLES")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("h3",{attrs:{id:"读锁-rl锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#读锁-rl锁"}},[s._v("#")]),s._v(" 读锁（RL锁）")]),s._v(" "),t("p",[s._v("读锁（Read Lock）是表锁的一种，允许其他事务读取表，但不允许写入。")]),s._v(" "),t("h3",{attrs:{id:"写锁-wl锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写锁-wl锁"}},[s._v("#")]),s._v(" 写锁（WL锁）")]),s._v(" "),t("p",[s._v("写锁（Write Lock）是表锁的一种，不允许其他事务读取或写入表。")]),s._v(" "),t("h2",{attrs:{id:"锁的监控和诊断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁的监控和诊断"}},[s._v("#")]),s._v(" 锁的监控和诊断")]),s._v(" "),t("h3",{attrs:{id:"查看锁信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看锁信息"}},[s._v("#")]),s._v(" 查看锁信息")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 查看当前锁等待情况")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHOW")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ENGINE")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("INNODB")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("STATUS")]),s._v("\\G\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 查看锁等待详情（MySQL 5.7+）")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" performance_schema"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("data_locks"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" performance_schema"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("data_lock_waits"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 查看锁等待详情（MySQL 5.7之前）")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" information_schema"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("innodb_locks"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" information_schema"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("innodb_lock_waits"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 查看当前正在执行的事务")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" information_schema"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("innodb_trx"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("h3",{attrs:{id:"死锁检测和处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死锁检测和处理"}},[s._v("#")]),s._v(" 死锁检测和处理")]),s._v(" "),t("p",[s._v("InnoDB 存储引擎有内置的死锁检测机制，当检测到死锁时，会自动回滚一个事务来解除死锁。")]),s._v(" "),t("p",[t("strong",[s._v("死锁日志查看")]),s._v("：")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHOW")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ENGINE")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("INNODB")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("STATUS")]),s._v("\\G\n")])])]),t("p",[t("strong",[s._v("死锁预防措施")]),s._v("：")]),s._v(" "),t("ol",[t("li",[s._v("按照固定的顺序访问表和行")]),s._v(" "),t("li",[s._v("尽量使用主键或唯一索引进行更新操作")]),s._v(" "),t("li",[s._v("避免长事务")]),s._v(" "),t("li",[s._v("使用合理的隔离级别")]),s._v(" "),t("li",[s._v("及时提交或回滚事务")])]),s._v(" "),t("h2",{attrs:{id:"锁的最佳实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁的最佳实践"}},[s._v("#")]),s._v(" 锁的最佳实践")]),s._v(" "),t("ol",[t("li",[t("p",[t("strong",[s._v("选择合适的锁粒度")]),s._v("：根据业务需求选择合适的锁粒度，一般情况下，行锁的并发性能优于表锁")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("使用合适的隔离级别")]),s._v("：不同的隔离级别使用不同的锁机制，根据业务需求选择合适的隔离级别")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("避免长事务")]),s._v("：长事务会长时间持有锁，降低系统并发性能")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("合理设计索引")]),s._v("：InnoDB 的行锁是通过索引实现的，合理设计索引可以提高锁的效率")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("避免锁升级")]),s._v("：尽量避免锁升级（如从行锁升级到表锁），可以通过使用索引、拆分大事务等方式实现")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("使用乐观锁代替悲观锁")]),s._v("：在读多写少的场景下，使用乐观锁可以提高并发性能")])]),s._v(" "),t("li",[t("p",[t("strong",[s._v("定期监控锁状态")]),s._v("：定期监控数据库的锁状态，及时发现和解决锁问题")])])]),s._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),t("p",[s._v("MySQL 的锁机制是保证数据一致性和完整性的重要手段，了解不同类型的锁及其使用场景，可以帮助我们设计出高性能、高可靠性的数据库应用。在实际应用中，需要根据业务需求和系统特点，选择合适的锁类型和锁策略，平衡数据一致性和系统性能。")]),s._v(" "),t("p",[s._v("锁是数据库并发控制的基础，但过度使用锁会导致系统性能下降，因此需要在保证数据一致性的前提下，尽量减少锁的使用，提高系统的并发性能。")])])}),[],!1,null,null,null);t.default=v.exports}}]);